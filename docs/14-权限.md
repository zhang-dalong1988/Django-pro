# 第 14 章：权限

目前，我们的 Bookstore 项目没有设置任何权限。任何用户，甚至未登录的用户，都可以访问任何页面并执行任何可用操作。虽然这对于原型设计来说是可以的，但在将网站部署到生产环境之前，实施一个健全的权限结构是必须的。

Django 提供了内置的授权选项，可以将页面锁定为仅登录用户、特定组或具有适当个人权限的用户。

## 仅限登录用户

令人困惑的是，即使是添加最基本的权限（仅限登录用户访问）也有多种方法。可以使用原始方式使用 `login_required()` 装饰器，或者由于我们到目前为止使用的是基于类的视图，可以通过 LoginRequired mixin 实现。

让我们首先限制只有登录用户才能访问 Books 页面。导航栏中有一个链接，所以这不是用户意外发现 URL 的情况（这也可能发生）；在这种情况下，URL 是相当公开的。

首先在顶部导入 LoginRequiredMixin，然后将其添加到我们的 BookListView 类中。重要的是 LoginRequiredMixin 必须在 ListView 之前，以便正常工作。Mixins 功能强大，但在实践中可能有点棘手。正如官方文档所指出的，"并非所有 mixins 都可以一起使用，并非所有基于类的通用视图都可以与所有其他 mixins 一起使用..."

第二个更新是添加一个 login_url，用户将被重定向到该 URL。这是登录的 URL 名称，由于我们使用的是 django-allauth，所以是 account_login。如果我们使用传统的 Django 认证系统，那么这个链接将简单地称为 login。

BookDetailView 的结构相同：在 DetailView 之前添加 LoginRequiredMixin，并添加 login_url 路由。

```python
# books/views.py

from django.contrib.auth.mixins import LoginRequiredMixin # new
from django.views.generic import ListView, DetailView

from .models import Book

class BookListView(LoginRequiredMixin, ListView): # new
    model = Book
    context_object_name = "book_list"
    template_name = "books/book_list.html"
    login_url = "account_login" # new

class BookDetailView(LoginRequiredMixin, DetailView): # new
    model = Book
    context_object_name = "book"
    template_name = "books/book_detail.html"
    login_url = "account_login" # new
```

就是这样！如果你现在退出你的账户并点击"Books"链接，它将自动重定向到登录页面。但是，如果你已登录，Books 页面将正常加载。即使你以某种方式知道特定书籍页面的 UUID，你仍然会被重定向到登录页面！

## 权限

Django 带有一个基本的权限系统，通过 Django 管理界面控制。为了演示它，我们需要创建一个新的用户账户。导航回管理主页，然后点击用户旁边的"+ Add"。

我们将这个新用户命名为 special ，并设置密码为 testpass123 。点击"Save"按钮。第二页允许我们设置"Email address"为 special@email.com 。在页面底部进一步滚动，有设置组和用户权限的选项。这是 Django 提供的一长串默认选项。现在我们不会使用它们，因为我们将在下一节创建一个自定义权限，所以只需点击右下角的"Save"按钮，以便更新用户账户的电子邮件地址。

## 自定义权限

在 Django 项目中，设置自定义权限是一个更常见的操作。我们可以通过数据库模型上的 Meta 类来设置它们。

例如，让我们添加一个特殊状态，使作者可以阅读所有书籍。换句话说，他们可以访问 DetailView。我们可以对权限进行更具体的设置，按书籍限制它们，但这是一个很好的第一步。

在 books/models.py 文件中，我们将添加一个 Meta 类，并设置权限名称和描述，这将在管理界面中可见。

```python
# books/models.py

...
class Book(models.Model):
    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False)
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=200)
    price = models.DecimalField(max_digits=6, decimal_places=2)
    cover = models.ImageField(upload_to="covers/", blank=True)

    class Meta: # new
        permissions = [
            ("special_status", "Can read all books"),
        ]

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse("book_detail", args=[str(self.id)])
...
```

这里内部类和方法的顺序是经过深思熟虑的。它遵循 Django 文档中的模型风格部分。

由于我们已经更新了数据库模型，我们必须创建一个新的迁移文件，然后迁移数据库以应用它。

```shell
$ docker-compose exec web python manage.py makemigrations books
Migrations for 'books':
  books/migrations/0004_alter_book_options.py - Change Meta options on book
$ docker-compose exec web python manage.py migrate
Operations to perform:
  Apply all migrations: account, accounts, admin, auth, books, contenttypes, sessions, si\
tes
Running migrations:
  Applying books.0004_alter_book_options... OK
```

## 用户权限

现在我们需要将这个自定义权限应用到我们的新 special 用户。多亏了管理界面，这不是一个困难的任务。导航到用户部分，其中列出了三个现有用户：special@email.com、testuser@email.com 和你的超级用户账户（我的电子邮件地址是 will@wsvincent.com）。

点击 special@email.com 用户，然后滚动到页面底部附近的用户权限。在其中搜索 books | book | Can read all books 并选择它。

点击 -> 箭头将其添加到"Chosen user permissions"。不要忘记点击页面底部的"Save"按钮。

## PermissionRequiredMixin

最后一步是使用 PermissionRequiredMixin 应用自定义权限。基于类的视图的许多优点之一是，我们可以用很少的代码实现高级功能，这个特定的 mixin 就是一个很好的例子。

我们将在顶行添加 PermissionRequiredMixin 到我们的导入列表中。然后将其添加到 DetailView 中，在 LoginRequiredMixin 之后但在 DetailView 之前。这个顺序应该是有意义的：如果用户尚未登录，检查他们是否有权限是没有意义的。最后添加一个 permission_required 字段，指定所需的权限。在我们的例子中，它的名称是 special_status，存在于 books 模型上。

```python
# books/views.py

from django.contrib.auth.mixins import (
    LoginRequiredMixin,
    PermissionRequiredMixin # new
)
from django.views.generic import ListView, DetailView

from .models import Book

class BookListView(LoginRequiredMixin, ListView):
    model = Book
    context_object_name = "book_list"
    template_name = "books/book_list.html"
    login_url = "account_login"

class BookDetailView(
    LoginRequiredMixin,
    PermissionRequiredMixin, # new
    DetailView):
    model = Book
    context_object_name = "book"
    template_name = "books/book_detail.html"
    login_url = "account_login"
    permission_required = "books.special_status" # new
```

可以通过 permission_required 字段添加多个权限，尽管我们在这里没有这样做。

要测试我们的工作，请退出管理员。这是必要的，因为超级用户账户用于管理员，默认情况下可以访问所有内容。不是一个很好的测试用户账户！

使用 testuser@email.com 账户登录到 Bookstore 网站，然后导航到 Books 页面，列出三个可用标题。如果你点击任何一本书，你会看到一个"403 Forbidden"错误，因为权限被拒绝。

现在回到主页 http://127.0.0.1:8000/ 并退出。然后使用 special@email.com 账户登录。再次导航到 Books 页面，每个单独的书籍页面都是可访问的。

## 组 & UserPassesTestMixin

第三个可用的权限 mixin 是 UserPassesTestMixin，它限制视图的访问仅限于通过特定测试的用户。

在大型项目中，组（Django 应用权限到用户类别的方式）变得突出。如果你查看管理主页，有一个专门的组部分，可以在其中添加组并设置权限。这比在每个用户的基础上添加权限要高效得多。

组的一个例子是，如果你的网站有一个高级部分，用户升级可以将他们切换到高级组，然后访问涉及的任何特定额外权限。

## 测试

每当代码发生变化时，运行测试是个好主意。毕竟，测试的全部意义在于检查我们是否无意中导致应用程序的另一部分失败。

```shell
$ docker-compose exec web python manage.py test
...
Ran 17 tests in 0.249s

FAILED (failures=2)
```

事实证明，我们确实有一些失败的测试！具体来说，test_book_list_view 和 test_book_detail_view 都抱怨 302 状态码，意味着重定向，而不是成功的 200。这是因为我们刚刚添加了要求登录才能查看书籍列表，而对于详情页面，用户必须具有 special_status 权限。

第一步是从内置的 auth 模型中在文件顶部附近导入 Permission。然后在 books/tests.py 中的 BookTests 内添加 special_status 权限到 setUpTestData 方法，使其对所有测试可用。

然后我们将现有的 test_book_list_view 测试转换为两个不同的测试：一个用于已登录用户（test_book_list_view_for_logged_in_user），一个用于未登录用户（test_book_list_view_for_logged_out_user）。最后，我们将更新并重命名现有的 test_book_detail_view 为 test_book_detail_view_with_permissions，并检查用户是否具有正确的权限。

以下是完全更新的代码：

代码

```python
# books/tests.py

from django.contrib.auth import get_user_model
from django.contrib.auth.models import Permission # new
from django.test import Client, TestCase
from django.urls import reverse

from .models import Book, Review

class BookTests(TestCase):

    @classmethod
    def setUpTestData(cls):
        cls.user = get_user_model().objects.create_user(
            username="reviewuser",
            email="reviewuser@email.com",
            password="testpass123"
        )

        cls.special_permission = Permission.objects.get(
           codename="special_status"
       )  # new

        cls.book = Book.objects.create(
            title="Harry Potter",
            author="JK Rowling",
            price="25.00",
        )

        cls.review = Review.objects.create(
            book = cls.book,
            author = cls.user,
            review = "An excellent review",
        )

    def test_book_listing(self):
        self.assertEqual(f"{self.book.title}", "Harry Potter")
        self.assertEqual(f"{self.book.author}", "JK Rowling")
        self.assertEqual(f"{self.book.price}", "25.00")

    def test_book_list_view_for_logged_in_user(self): # new
        self.client.login(email="reviewuser@email.com", password="testpass123")
        response = self.client.get(reverse("book_list"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "Harry Potter")
        self.assertTemplateUsed(response, "books/book_list.html")

    def test_book_list_view_for_logged_out_user(self):  # new
        self.client.logout()
        response = self.client.get(reverse("book_list"))
        self.assertEqual(response.status_code, 302)  # new
        self.assertRedirects(
            response, "%s?next=/books/" % (reverse("account_login")))
        response = self.client.get(
            "%s?next=/books/" % (reverse("account_login")))
        self.assertContains(response, "Log In")

    def test_book_detail_view_with_permissions(self): # new
        self.client.login(email="reviewuser@email.com", password="testpass123")
        self.user.user_permissions.add(self.special_permission)
        response = self.client.get(self.book.get_absolute_url())
        no_response = self.client.get("/books/12345/")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(no_response.status_code, 404)
        self.assertContains(response, "Harry Potter")
        self.assertContains(response, "An excellent review")
        self.assertTemplateUsed(response, "books/book_detail.html")
```

如果你再次运行测试套件，所有测试都应该通过。

```shell
$ docker-compose exec web python manage.py test
...
Ran 18 tests in 0.384s

OK
```

## Git

确保为本章的更改创建一个新的 Git 提交。

```shell
$ git status
$ git add .
$ git commit -m 'ch14'
```

像往常一样，你可以将你的代码与 Github 上的官方源代码进行比较。

## 结论

权限和组是一个高度主观的话题，可能因项目而异。然而，基本方法保持不变，模仿我们在这里所涵盖的内容：首先限制访问，然后根据需要逐渐放宽对用户的限制。在我们的例子中，我们将访问限制为仅登录用户，然后添加了关于哪些登录用户组可以查看的额外权限。

在下一章中，我们将为我们的 Bookstore 网站添加搜索功能。
