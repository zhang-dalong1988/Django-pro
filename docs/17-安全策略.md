# 第 17 章：安全策略

万维网是一个危险的地方。有许多恶意行为者和更多的自动化机器人会试图入侵您的网站并造成损害。因此，理解和实施安全功能是任何网站的必需品。

幸运的是，Django 在安全方面有着非常强的记录，这得益于其多年处理 Web 安全问题的经验以及强大而定期的安全更新周期。

然而，与任何工具一样，正确实施安全功能很重要，在本章中，我们将介绍如何在我们的书店项目中做到这一点。

## 社会工程学

任何网站最大的安全风险最终不是技术性的：而是人。社会工程学一词指的是寻找有权访问系统的个人，他们会自愿或不自愿地与恶意行为者分享其登录凭据的技术。

如今，如果您在技术组织中，钓鱼攻击可能是最可能的罪魁祸首。只需要在电子邮件链接上点击一次错误，恶意行为者就可能获得对系统的访问权限，或者至少获得被攻击员工拥有的所有访问权限。

为了减轻这种风险，请实施强大的权限方案，只提供员工需要的确切安全访问权限，而不是更多。每个工程师都需要访问生产数据库吗？可能不需要。非工程师需要写入访问权限吗？同样，可能不需要。这些是最好提前讨论的问题，一个好的默认做法是只在需要时添加权限，而不是默认为每个人都提供超级用户状态！

## Django 更新

保持您的项目与最新版本的 Django 保持同步是保持安全的另一个重要方式。我不仅仅是指与最新功能版本（3.2、4.0、4.1 等）保持同步，这些版本大约每 8 个月发布一次。还有每月的安全补丁更新，形式为 4.0.1、4.0.2、4.0.3 等。

那么长期支持（LTS）版本呢？某些功能版本被指定为 LTS，并在保证的时间内（通常约 3 年）接收安全和数据丢失修复。例如，Django 3.2 LTS 于 2021 年 4 月发布，将获得扩展支持直到 2024 年 4 月。Django 4.2，下一个 LTS 版本，将于 2023 年 4 月发布，并将获得扩展支持直到 2026 年 4 月。

您可以只停留在 LTS 版本上而不在中间升级吗？可以。您应该这样做吗？不应该。如果可能的话，最好也更安全的是保持与最新版本的 Django 同步。

抵制许多现实世界项目的诱惑和现实，即不将一部分开发人员时间用于保持与 Django 版本的同步。网站就像汽车：它需要定期维护才能以最佳状态运行。如果您推迟更新，只会使问题复杂化。

如何更新？Django 具有弃用警告功能，可以并且应该通过键入`python -Wa manage.py test`为每个新版本运行。从 3.0 更新到 3.1 再到 3.2 并每次运行弃用警告要比跳过多个版本好得多。

## 部署检查清单

为了协助部署和检查安全设置，Django 文档包含一个专门的部署检查清单，进一步描述了安全设置。

更好的是，我们可以运行一个命令来自动化 Django 的建议，`python manage.py check --deploy`，它将检查项目是否准备好部署。它使用 Django 系统检查框架，可以用于在成熟项目中自定义类似的命令。

由于我们在 Docker 中工作，我们必须在命令前加上`docker-compose exec web`。

```shell
$ docker-compose exec web python manage.py check --deploy
System check identified some issues:

WARNINGS:
...
System check identified 6 issues (0 silenced).
```

太好了！一个描述性和冗长的问题列表，我们可以逐一解决，为我们的书店项目准备生产环境。

## docker-compose-prod.yml

最终，我们的本地开发设置将与我们的生产设置不同。我们已经在第 9 章：环境变量中开始配置这个。回想一下，我们为`SECRET_KEY`、`DEBUG`和`DATABASES`添加了环境变量。但我们没有设置生产值或在本地和生产之间高效切换的方法。

有许多方法来解决这个挑战。我们的方法将是创建一个专门的`docker-compose-prod.yml`文件，我们可以用它来在本地测试生产环境。当涉及到将我们的项目部署到生产环境时，我们将手动更新环境变量以匹配。

首先，在基础目录中创建一个`docker-compose-prod.yml`文件。它将位于现有的`docker-compose.yml`文件旁边。然后立即将其添加到我们现有的`.gitignore`文件中。我们绝对不希望我们的生产秘密存储在 Git 中并在源代码中可用。

**.gitignore**

```
.venv
**pycache**/
db.sqlite3
.DS_Store # Mac only
docker-compose-prod.yml
```

如果您好奇，Github 维护一个官方的 Python gitignore 文件，包含值得进一步探索的其他配置。

再次运行`git status`，`docker-compose-prod.yml`文件不可见，即使它仍在我们的项目中。这就是我们想要的！

现在，将`docker-compose.yml`文件的内容复制到`docker-compose-prod.yml`中。

**docker-compose-prod.yml**

```yaml
version: "3.9"

services:
  web:
    build: .
    command: python /code/manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/code
    ports:
      - 8000:8000
    depends_on:
      - db
    environment:
      - "DJANGO_SECRET_KEY=django-insecure-hv1(e0r@v4n4m6gqdz%dn(60o=dsy8&@0_lbs8p-v3u^bs4)xl"
      - "DJANGO_DEBUG=True"
  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - "POSTGRES_HOST_AUTH_METHOD=trust"

volumes:
  postgres_data:
```

要运行我们的新文件，关闭 Docker 容器并通过`-f`标志重新启动它以指定替代的 compose 文件。默认情况下，Docker 假设一个`docker-compose.yml`，所以在这种情况下添加`-f`标志是不必要的。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
```

导航到网站，一切都应该像以前一样运行，即使我们使用不同的 compose 文件。

## DEBUG

最终，我们在本章中的目标是通过使用`docker-compose-prod.yml`文件通过 Django 的部署检查清单。让我们从更改`DEBUG`开始，它设置为 True，但在生产中应该为 False。

**docker-compose-prod.yml**

```yaml
environment:
  - "DJANGO_SECRET_KEY=django-insecure-hv1(e0r@v4n4m6gqdz%dn(60o=dsy8&@0_lbs8p-v3u^bs4)xl"
  - "DJANGO_DEBUG=False" # new
```

在进行更改后关闭 Docker 容器并重新启动以重新加载更改的环境变量。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
```

网站应该像以前一样运行，但要检查`DEBUG`是否设置为 False，请访问一个不存在的页面，如`http://127.0.0.1:8000/debug`。

有一个通用的"未找到"消息，确认我们将`DEBUG`设置为 False。因为如果它是 True，就会有详细的错误报告。

让我们再次运行 Django 部署检查清单，现在`DEBUG`已经更改。回想一下，当我们在本章早期运行它时有 6 个问题。

```shell
$ docker-compose exec web python manage.py check --deploy
System check identified some issues:

WARNINGS:
...
System check identified 5 issues (0 silenced).
```

我们降到了 5 个，因为`DEBUG`设置为 False。进步！

## 默认值

环境变量在我们的 Django 项目中有两个目的：它们保持像`SECRET_KEY`这样的项目实际上是秘密的，它们充当在本地和生产设置之间切换的方式。虽然为像`DEBUG`这样的设置有两个环境变量没有什么问题，但当我们不需要保持某些东西秘密时，使用默认值可以说更清洁。

例如，让我们重写`DEBUG`配置如下：

```python
# django_project/settings.py
DEBUG = env.bool("DJANGO_DEBUG", default=False)  # new
```

这意味着如果没有环境变量存在，默认为生产值 False。如果有一个可用的，`DJANGO_DEBUG`，那么使用它。

这种默认为最安全、仅生产设置的方法更安全，因为如果由于某种原因环境变量没有正确加载，我们不希望网站只使用不安全的本地开发变量。换句话说，控制需要放松才能工作，而不是收紧。这类似于我们在本书早期对用户权限采取的方法。

现在继续更新`docker-compose-prod.yml`，通过删除`DJANGO_DEBUG`，使只有`DJANGO_SECRET_KEY`在环境部分下。

**docker-compose-prod.yml**

```yaml
environment:
  - "DJANGO_SECRET_KEY=django-insecure-hv1(e0r@v4n4m6gqdz%dn(60o=dsy8&@0_lbs8p-v3u^bs4)xl"
```

如果您再次用`docker-compose down`关闭 Docker 并重新启动生产版本，网站仍将正常工作。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
```

## SECRET_KEY

Django 部署检查清单抱怨的五个当前问题之一是`SECRET_KEY`，它在每次运行`startproject`命令时由 Django 随机生成。它用于在整个项目中提供加密签名，保持安全非常非常重要。

我们当前的`SECRET_KEY`不安全，因为它已经多次添加到 Git 源代码控制中。即使我们现在将其当前值移动到环境变量，该值也将永远存在于我们的 Git 历史中。因此，必须生成新的`SECRET_KEY`并正确存储。它需要至少有 50 个字符，五个或更多唯一字符，并且不能以"django-insecure-"为前缀！

幸运的是，生成新的随机密钥很容易。我们可以使用 Python 的内置 secrets 模块。参数`token_urlsafe`返回 URL 安全文本字符串中的字节数。使用 Base64 编码，平均每个字节有 1.3 个字符。所以在这种情况下使用 38 会产生 51 个字符。

```shell
$ docker-compose exec web python -c "import secrets; print(secrets.token_urlsafe(38))"
LHanzMtuuenbzKGXGBSHZYHXrydW3_4zBeEE7WRtZGIrO0NNCbs
```

快速提醒，由于我们使用 Docker，如果您的`SECRET_KEY`包含美元符号`$`，那么您需要添加额外的美元符号`$$`。这是由于 docker-compose 处理变量替换的方式。否则您会看到错误！

将新的`SECRET_KEY`添加到`docker-compose-prod.yml`文件中，使其如下所示：

**docker-compose-prod.yml**

```yaml
# docker-compose-prod.yml
environment:
  - "DJANGO_SECRET_KEY=LHanzMtuuenbzKGXGBSHZYHXrydW3_4zBeEE7WRtZGIrO0NNCbs"
```

因为`docker-compose-prod.yml`在我们的`.gitignore`文件中，它不会出现在我们的源代码中。重新启动现在使用真正秘密的`SECRET_KEY`的 Docker 容器。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
```

网站应该像以前一样工作。再次运行部署检查清单：

```shell
$ docker-compose exec web python manage.py check --deploy
System check identified some issues:

WARNINGS:
...
System check identified 4 issues (0 silenced).
```

我们现在降到了 4 个问题，但首先简要深入了解 Web 安全，这样我们就可以理解为什么这些设置如此重要。

## Web 安全

即使 Django 默认处理大多数常见的安全问题，理解频繁的攻击方法和 Django 采取的缓解步骤仍然至关重要。您可以在 Django 安全页面上找到概述，但我们将在这里进行更深入的探讨。

Django 默认带有许多额外的安全中间件，可以防范其他请求/响应周期攻击。

对每个的完整解释超出了本书的范围，但值得阅读 Django 安全团队多年来提供的保护。没有充分理由不要更改默认值。

### SQL 注入

让我们从 SQL 注入攻击开始，当恶意用户可以在数据库上执行任意 SQL 代码时就会发生这种攻击。考虑网站上的登录表单。如果恶意用户输入`DELETE from users WHERE user_id=user_id`会发生什么？如果在没有适当保护的情况下对数据库运行此操作，可能会导致删除所有用户记录！不好。这个 XKCD 漫画提供了一个幽默但可能准确的例子，说明这是如何发生的。

幸运的是，Django ORM 在构建查询集时默认自动清理用户输入，以防止这种类型的攻击。您需要小心的是 Django 确实提供了执行自定义 sql 或原始查询的选项。这两者都应该极其谨慎地使用，因为它们可能会打开 SQL 注入的漏洞。

非营利组织开放 Web 应用程序安全项目（OWASP）有一个出色且非常详细的 SQL 注入备忘单，建议进一步阅读。

### XSS（跨站脚本攻击）

跨站脚本（XSS）是另一种经典攻击，当攻击者能够将小段代码注入到其他人查看的网页上时就会发生。这种代码，通常是 JavaScript，如果存储在数据库中，然后将被检索并显示给其他用户。

例如，考虑我们当前网站上用于撰写书评的表单。如果用户不是输入"这本书很棒"，而是输入带有 JavaScript 的内容会怎样？例如，`<script>alert('hello');</script>`。如果这个脚本存储在数据库中，那么每个未来用户的页面都会有一个弹出窗口说"hello"。虽然这个特定的例子更令人讨厌而不是危险，但容易受到 XSS 攻击的网站非常危险，因为恶意用户可以将任何 JavaScript 插入页面，包括从毫无戒心的用户那里窃取几乎任何东西的 JavaScript。

为了防止 XSS 攻击，Django 模板自动转义可能危险的特定字符，包括括号（`<`和`>`）、单引号`'`、双引号`"`和和号`&`。在某些边缘情况下，您可能想要关闭自动转义，但这应该极其谨慎地使用。

建议进一步阅读 OWASP 的 XSS 备忘单。

### 跨站请求伪造（CSRF）

跨站请求伪造（CSRF）是第三种主要攻击类型，虽然知名度不如 SQL 注入或 XSS，但同样危险。它的核心原理是利用网站对用户浏览器的信任关系。

当用户登录网站时（以银行网站为例），服务器会为该用户生成一个会话令牌。这个令牌包含在后续所有请求的 HTTP 标头中，用于验证用户身份。问题在于，如果恶意攻击者获得了这个会话令牌的访问权限会发生什么？

举个具体例子：用户在一个浏览器标签页中登录了银行账户，然后在另一个标签页中打开邮箱，点击了一个看似正常的邮件链接。这个链接表面上合法，实际上却指向用户已登录的银行网站！攻击者巧妙地利用用户的登录状态，在用户毫不知情的情况下，使用其凭据将资金转移到攻击者的账户中。

实际上，CSRF 攻击的实现方式多种多样，不仅限于恶意链接，还包括隐藏表单、特制的图像标签，甚至是 AJAX 请求。

Django 提供了完善的 CSRF 防护机制：通过 CSRF 中间件在 cookie 中存储随机密钥，同时在表单中通过 `csrf_token` 模板标签嵌入相同的密钥。由于第三方网站无法访问用户的 cookie，任何密钥不匹配的情况都会触发错误，从而阻止攻击。

当然，Django 也允许自定义配置：可以禁用 CSRF 中间件，并在特定视图上使用 `csrf_protect()` 装饰器。但这种操作需要极其谨慎，必须充分理解其安全影响。

OWASP 的 CSRF 防护备忘单提供了该问题的全面分析。值得注意的是，几乎所有主流网站都曾遭受过 CSRF 攻击。

实用建议：每当在网站中使用表单时，都应该考虑是否需要包含 `csrf_token` 标签。在绝大多数情况下，答案都是肯定的！

### 点击劫持保护

点击劫持是另一种攻击，恶意网站欺骗用户点击隐藏框架。内部框架，称为 iframe，通常用于在另一个网站中嵌入一个网站。例如，如果您想在您的网站上包含 Google 地图或 YouTube 视频，您将包含将该网站放在您自己网站中的 iframe 标签。这非常方便。

但它有一个安全风险，即框架可以对用户隐藏。考虑如果用户已经登录到他们的 Amazon 账户，然后访问一个声称是小猫图片的恶意网站。用户点击所述恶意网站以查看更多小猫，但实际上他们点击了一个 Amazon 商品的 iFrame，该商品在不知情的情况下被购买。这只是点击劫持的一个例子。

为了防止这种情况，Django 带有默认的点击劫持中间件，它设置一个`X-Frame-Options` HTTP 标头，指示是否允许资源在框架或 iframe 中加载。如果需要，您可以关闭此保护，甚至可以在每个视图级别设置它。但是，要以高度谨慎和研究的态度这样做。

## HTTPS/SSL

所有现代网站都应该使用 HTTPS，它提供客户端和服务器之间的加密通信。HTTP（超文本传输协议）是现代 Web 的支柱，但默认情况下它没有加密。

HTTPS 中的"s"指的是其加密性质，首先是由于 SSL（安全套接字层），现在是其后继者 TLS（传输层安全）。启用 HTTPS 后，我们将在部署章节中进行，恶意行为者无法嗅探传入和传出的流量以获取身份验证凭据或 API 密钥等数据。

我们 Django 部署检查清单中剩余的 4 个问题之一是`SECURE_SSL_REDIRECT`当前设置为 False。出于安全原因，在生产中强制将其设置为 True 要好得多。让我们现在更改它。在`django_project/settings.py`文件的底部添加`SECURE_SSL_REDIRECT`的配置：将其设置为环境变量`DJANGO_SECURE_SSL_REDIRECT`或默认值 True。

```python
# django_project/settings.py
SECURE_SSL_REDIRECT = env.bool("DJANGO_SECURE_SSL_REDIRECT", default=True)
```

然后我们将环境变量添加到`docker-compose.yml`中，以便对于本地开发，它默认为 False，这是较不安全的设置。

**docker-compose.yml**

```yaml
# docker-compose.yml
environment:
  - "DJANGO_SECRET_KEY=django-insecure-hv1(e0r@v4n4m6gqdz%dn(60o=dsy8&@0_lbs8p-v3u^bs4)xl"
  - "DJANGO_DEBUG=True"
  - "DJANGO_SECURE_SSL_REDIRECT=False" # new
```

重新启动 Docker 并再次运行部署检查清单。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
$ docker-compose exec web python manage.py check --deploy
...
System check identified 3 issues (0 silenced).
```

我们现在降到了 3 个问题。

### SSL 错误

如果您现在尝试访问网站，会有一个问题。

似乎有某种 SSL 协议错误，这是有道理的，因为我们刚刚更新了 SSL 设置。我们在哪里可以找到更多信息呢？试试日志如何：

```shell
$ docker-compose logs
...
You're accessing the development server over HTTPS, but it only supports HTTP.
```

啊，这更具描述性。由于我们将默认值切换为 True，我们的网站自动强制执行 SSL。但问题是本地 Django 服务器只能通过 HTTP 工作。我们可以运行部署检查清单来获得对`docker-compose-prod.yml`中生产设置的信心，但就实际在本地使用生产网站而言，我们将无法强制执行 SSL。

不过这没关系。这是我们有单独的本地和生产配置的许多原因之一。公司通常实际上设置了三种不同的环境：一种用于本地，一种用于生产，一种用于模拟生产但允许在完全切换之前进行更多实际测试的暂存服务器。暂存服务器通常部署但具有隐藏的 URL 和额外的权限，因此只有团队开发人员可以尝试它。

今后，如果您想尝试使用生产设置的本地网站，请注意您必须关闭`DJANGO_SECURE_SSL_REDIRECT`。

另一个常见的陷阱是，即使您重新启动 Docker 容器并启动本地配置，您的 Web 浏览器可能仍然抱怨 SSL 错误。

```shell
$ docker-compose down
$ docker-compose up -d
```

这是因为大多数 Web 浏览器一旦发现网站的 HTTPS 版本存在——即使它是像`http://127.0.0.1:8000/`这样的 localhost——也会缓存它并持续恢复到它。您可以查找清除缓存的不同方法，但在这种情况下最有效的是重新启动您的 Web 浏览器。一如既往，当某些东西不工作时，尝试关闭它并重新启动。

## HTTP 严格传输安全（HSTS）

HTTP 严格传输安全（HSTS）是一种安全策略，让我们的服务器通过添加`Strict-Transport-Security`标头来强制 Web 浏览器只能通过 HTTPS 交互。

在我们的`settings.py`文件中有三个隐式 HSTS 配置需要为生产更新：

```python
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
```

`SECURE_HSTS_SECONDS`设置默认设置为 0，但出于安全目的，越大越好。我们将在我们的项目中将其设置为推荐的 30 天，或 2,592,000 秒。

`SECURE_HSTS_INCLUDE_SUBDOMAINS`强制子域使用 SSL。我们将在生产中将其设置为 True。

`SECURE_HSTS_PRELOAD`只有在`SECURE_HSTS_SECONDS`有非零值时才有效果，但由于我们刚刚设置了一个，我们需要将其设置为 True。

将这三行添加到`django_project/settings.py`文件的底部。

```python
# django_project/settings.py
SECURE_HSTS_SECONDS = env.int("DJANGO_SECURE_HSTS_SECONDS", default=2592000)  # 30 days
SECURE_HSTS_INCLUDE_SUBDOMAINS = env.bool("DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS", default=True)
SECURE_HSTS_PRELOAD = env.bool("DJANGO_SECURE_HSTS_PRELOAD", default=True)
```

然后用本地开发值更新`docker-compose.yml`。

```yaml
# docker-compose.yml
environment:
  - "DJANGO_SECRET_KEY=django-insecure-hv1(e0r@v4n4m6gqdz%dn(60o=dsy8&@0_lbs8p-v3u^bs4)xl"
  - "DJANGO_DEBUG=True"
  - "DJANGO_SECURE_SSL_REDIRECT=False"
  - "DJANGO_SECURE_HSTS_SECONDS=0" # new
  - "DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS=False" # new
  - "DJANGO_SECURE_HSTS_PRELOAD=False" # new
```

重新启动 Docker 并再次运行部署检查清单。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
$ docker-compose exec web python manage.py check --deploy
...
System check identified 2 issues (0 silenced).
```

只剩下 2 个问题了！

## 安全 Cookie

HTTP Cookie 用于在客户端计算机上存储信息，如身份验证凭据。这是必要的，因为 HTTP 协议在设计上是无状态的：除了在 HTTP 标头中包含标识符之外，没有办法判断用户是否已通过身份验证！

Django 使用会话和 cookie 来实现这一点，大多数网站也是如此。但 cookie 也可以并且应该通过`SESSION_COOKIE_SECURE`配置强制通过 HTTPS。默认情况下，Django 将此值设置为 False 用于本地开发；在生产中它需要为 True。

第二个问题是`CSRF_COOKIE_SECURE`，它默认为 False，但在生产中应该为 True，以便只有标记为"安全"的 cookie 才会与 HTTPS 连接一起发送。

再次将这两行添加到`django_project/settings.py`的底部。

```python
# django_project/settings.py
SESSION_COOKIE_SECURE = env.bool("DJANGO_SESSION_COOKIE_SECURE", default=True)
CSRF_COOKIE_SECURE = env.bool("DJANGO_CSRF_COOKIE_SECURE", default=True)
```

然后更新`docker-compose.yml`文件。

```yaml
# docker-compose.yml
environment:
  - "DJANGO_SECRET_KEY=django-insecure-hv1(e0r@v4n4m6gqdz%dn(60o=dsy8&@0_lbs8p-v3u^bs4)xl"
  - "DJANGO_DEBUG=True"
  - "DJANGO_SECURE_SSL_REDIRECT=False"
  - "DJANGO_SECURE_HSTS_SECONDS=0"
  - "DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS=False"
  - "DJANGO_SECURE_HSTS_PRELOAD=False"
  - "DJANGO_SESSION_COOKIE_SECURE=False" # new
  - "DJANGO_CSRF_COOKIE_SECURE=False" # new
```

重新启动 Docker 并再次运行部署检查清单。

```shell
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d
$ docker-compose exec web python manage.py check --deploy
System check identified no issues (0 silenced).
```

没有更多问题了。万岁！

## 管理员加固

到目前为止，一般的安全建议似乎是依赖 Django 默认值，使用 HTTPS，在表单上添加`csrf_token`标签，并设置权限结构。都是正确的。但 Django 不代表我们采取的一个额外步骤是加固 Django 管理员。

考虑到每个 Django 网站默认将管理员设置为`/admin` URL。这是任何试图访问 Django 网站的黑客的主要嫌疑人。因此，一个简单的步骤就是简单地将管理员 URL 更改为字面上的任何其他内容！打开并更改 URL 路径。在这个例子中，它是`anything-but-admin/`。

```python
# django_project/urls.py
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django admin
    path("anything-but-admin/", admin.site.urls),  # new
    # User management
    path("accounts/", include("allauth.urls")),
    # Local apps
    path("", include("pages.urls")),
    path("books/", include("books.urls")),
]

if settings.DEBUG:
    import debug_toolbar
    urlpatterns = [
        path("__debug__/", include(debug_toolbar.urls)),
    ] + urlpatterns
```

一个有趣的第三方包`django-admin-honeypot`将生成一个虚假的管理员登录屏幕，并通过电子邮件向网站管理员发送任何试图在`/admin`攻击您网站的人的 IP 地址。然后可以将这些 IP 地址添加到网站的阻止地址列表中。

也可以通过`django-two-factor-auth`为您的管理员添加双因素身份验证，以获得更进一步的保护层。

## Git

本章在代码更改方面特别繁重，所以确保用 Git 提交所有更新。

```shell
$ git status
$ git add .
$ git commit -m 'ch17'
```

如果您有任何错误，请使用`docker-compose logs`检查您的日志，并将您的代码与 Github 上的官方源代码进行比较。

## 结论

安全是任何网站的主要关注点。通过使用`docker-compose-prod.yml`文件，我们可以在 Docker 中准确测试我们的生产设置，然后再将网站部署到线上。通过使用默认值，我们既可以简化文件中的环境变量，也可以确保如果环境变量出现问题，我们将默认为安全的生产值。Django 带有许多内置的安全功能，加上部署检查清单，我们现在可以高度自信地部署我们的网站，确保它是安全的。

最终，安全是一场持续的战斗，虽然本章中的步骤涵盖了大多数关注领域，但保持您的网站与最新 Django 版本同步对于持续安全至关重要。
