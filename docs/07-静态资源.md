# 第 7 章：静态资源

静态资源如 CSS、JavaScript 和图片是任何现代 Web 应用程序的核心组件。Django 为我们提供了围绕其配置和存储的很大灵活性，这对新手来说可能会令人困惑，但在实践中，所有项目的模式几乎都是相同的。在本章中，我们将配置初始静态资源并添加 Bootstrap 以改进样式。

## 1. 本地开发

对于本地开发，Django Web 服务器会自动提供静态文件，只需要最少的配置。静态文件可以放置在名为 static 的应用级目录中，例如，我们可以在 pages 应用中创建一个名为 pages/static/的新目录。

然而，大多数项目会在多个应用之间重用静态资源。我们的书店应用肯定会这样做！因此，更常见的方法是创建一个基础级目录 static 文件夹，并将所有静态文件放在其中。作为开发者，这更容易理解。

从命令行创建一个新的 static 文件夹以及 CSS、JavaScript 和图片的新子目录。

```bash
$ mkdir static
$ mkdir static/css
$ mkdir static/js
$ mkdir static/images
```

此时你的 Django 项目应该具有以下结构：

**项目结构**

```
├── Dockerfile
├── accounts
│   ...
├── db.sqlite3
├── django_project
│   ...
├── docker-compose.yml
├── manage.py
├── pages
│   ...
├── requirements.txt
├── static
│   ├── css
│   ├── images
│   └── js
└── templates
    ...
```

重要的是要知道，Git 默认情况下不会跟踪空目录。因此，当我们最终将代码推送到 GitHub 和 Heroku 时，这些空目录不会出现，这可能会在运行 collectstatic 时在部署中造成问题。为了避免这种情况，我们现在将向每个目录添加一个空文件。

在你的文本编辑器中创建以下三个文件：

- static/css/base.css
- static/js/base.js
- static/images/.keep

## 2. STATICFILES_DIRS

django_project/settings.py 文件的底部有一个关于"静态文件"的部分，它已经将 STATIC_URL 设置为"static/"。这是引用静态文件时使用的 URL。这意味着对于本地使用，所有静态文件都位于 http://127.0.0.1:8000/static/。

Django 附带的内置 staticfiles 应用——你可以在 django_project/settings.py 的 INSTALLED_APPS 部分看到它——附带了一个快速而简单的辅助视图，它将在本地为开发提供文件。它会自动在每个应用程序中查找 static 目录。

然而，许多静态文件不是特定于应用的，而是打算在项目范围内使用。这就是为什么创建基础目录 static 文件夹（如我们上面所做的）是一种常见做法。我们只需要为 Django 提供要查找的其他目录列表，这就是 STATICFILES_DIRS 的工作。由于这是一个列表，我们必须按照标准 Python 语法在其周围放置括号[]。

以下是更新后的 django_project/settings.py 文件应该看起来的样子。

```python
# django_project/settings.py

STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "static"]  # 新增
```

## 3. CSS

我们现在将更新 base.css 并保持简单，让我们的 h1 标题为红色。重点是展示如何将 CSS 添加到我们的项目中，而不是深入研究 CSS 本身。

```css
/* static/css/base.css */
h1 {
  color: red;
}
```

如果你现在刷新主页，你会看到什么都没有改变。这是因为静态资源必须显式加载到模板中！为此，我们必须在`_base.html` 的顶部添加`{% load static %}`，然后使用 static 模板标签来引用我们的 base.css 文件。即使此文件位于 static/css/base.css，我们也可以将其称为 css/base.css，因为 static 标签会自动在 STATIC_URL 中指定的 /static/ 目录中查找。

以下是更新后的 `templates/_base.html` 文件应该看起来的样子。

```html
<!-- templates/_base.html -->

{% load static %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>{% block title %}书店{% endblock %}</title>
    <!-- CSS -->
    <link rel="stylesheet" href="{% static 'css/base.css' %}" />
  </head>
  ...
</html>
```

刷新主页以查看我们的工作。

我们的 CSS 在起作用！如果你看到一个错误屏幕说"第 7 行的无效块标签：'static'。你忘记注册或加载这个标签了吗？"，那么你忘记在文件顶部包含{% load static %}行。我自己也经常这样做。

## 4. 图片

图片怎么样？你可以在此链接(https://github.com/wsvincent/djangoforprofessionals/blob/main/dfp.jpg)下载 Django for Professionals 的书籍封面。将其保存到目录 books/static/images 中，命名为 dfp.jpg。

要在主页上显示它，请通过在顶部添加{% load static %}标签来更新 templates/home.html。然后在<h1>标签下添加一个<img>类，该类也使用 static 来显示新封面。

```html
<!-- templates/home.html -->

{% extends "_base.html" %} {% load static %} {% block title %}首页{% endblock
title %} {% block content %}

<h1>这是我们的主页。</h1>
<img class="bookcover" src="{% static 'images/dfp.jpg' %}" />
{% if user.is_authenticated %}
<p>你好 {{ user.email }}！</p>
<p><a href="{% url 'logout' %}">登出</a></p>
{% else %}
<p>你尚未登录</p>
<p>
  <a href="{% url 'login' %}">登录</a> | <a href="{% url 'signup' %}">注册</a>
</p>
{% endif %} {% endblock content %}
```

刷新主页，你会看到原始文件相当大！让我们用一些额外的 CSS 来控制它。

```css
/* static/css/base.css */
h1 {
  color: red;
}

.bookcover {
  height: 300px;
  width: auto;
}
```

现在刷新主页，书籍封面图片很好地适合了。

如果你没有看到变化，你可能需要执行"硬刷新"来绕过你的 Web 浏览器的本地缓存。现代 Web 浏览器会自动保留已访问页面、图片和其他内容的本地副本以提高性能。有时这种自动缓存会导致浏览器显示过时的内容。解决方案是强制重新下载网页内容，也称为"硬刷新"或"缓存刷新"。在 Windows 上，这可以通过按住 Ctrl+F5 来完成；在 macOS 上按住 Cmd+Shift+R。

## 5. JavaScript

我们已经有一个 base.js 文件，可以用来向我们的项目添加 JavaScript。通常我会在这里放置某种跟踪代码，比如 Google Analytics，但为了演示目的，我们将添加一个 console.log 语句，以便我们可以确认 JavaScript 正确加载。

**代码**

```javascript
// static/js/base.js
console.log("JavaScript在这里！");
```

现在将其添加到我们的\_base.html 模板中。JavaScript 应该添加在文件底部，以便最后加载，在 HTML、CSS 和其他在 Web 浏览器中渲染时首先出现在屏幕上的资源之后。这给人一种完整网页加载更快的感觉。

**代码**

```html
<!-- templates/_base.html -->

{% load static %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>{% block title %}书店{% endblock title %}</title>
    <!-- CSS -->
    <link rel="stylesheet" href="{% static 'css/base.css' %}" />
  </head>
  <body>
    <div class="container">{% block content %} {% endblock content %}</div>
    <!-- JavaScript -->
    <script src="{% static 'js/base.js' %}"></script>
  </body>
</html>
```

在你的 Web 浏览器中，使 JavaScript 控制台可用。这涉及打开开发者工具并确保你在"控制台"部分。在本书中使用的 Chrome 上，转到顶部菜单中的 View，然后 Developer -> Developer Tools，这将打开一个侧边栏。确保从选项中选择 Console。

如果你刷新页面，你应该看到以下内容：

## 6. 生产环境

本地开发旨在为静态文件保持简单易用。无论它们位于单个应用中还是基础级目录中，Django 服务器都会为我们显示所有内容。但这种方法不是很高效，因为每个资源都必须从每个位置单独请求和提供。在生产环境中，将所有静态文件合并到一个位置并在单个更大的 HTTP 请求中提供服务要高效得多。

Django 附带了一个内置的管理命令 collectstatic，它为我们做这件事。但在 collectstatic 正常工作之前，我们需要在 django_project/settings.py 文件中配置另外两个设置。

第一个设置是 STATIC_ROOT，它设置这些收集文件的绝对位置。这可以命名为你喜欢的任何名称，但通常称为"staticfiles"。当在本地运行 collectstatic 时，它将合并 STATICFILES_DIRS 定义的所有可用静态文件，并将它们放置在 STATIC_ROOT 定义的目录中。我们将 STATIC_ROOT 设置为基础目录中名为 staticfiles 的目录。代码如下：

**代码**

```python
# django_project/settings.py

STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "static"]
STATIC_ROOT = BASE_DIR / "staticfiles"  # 新增
```

第二个设置是 STATICFILES_STORAGE，它是使用 collectstatic 命令收集静态文件时使用的文件存储引擎。默认情况下，它隐式设置为 django.contrib.staticfiles.storage.StaticFilesStorage。让我们现在在 django_project/settings.py 文件中明确这一点。

```python
# django_project/settings.py

STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "static"]
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_STORAGE = "django.contrib.staticfiles.storage.StaticFilesStorage"  # 新增
```

实际上还有一个默认的静态文件设置可用，STATICFILES_FINDERS，但它通常不被自定义，所以我们现在将其排除在 django_project/settings.py 文件之外。

现在我们可以运行命令 python manage.py collectstatic，它将把所有静态文件合并到一个新的 staticfiles 目录中。

**Shell**

```bash
(.venv) $ docker-compose exec web python manage.py collectstatic
131个静态文件复制到'/code/staticfiles'。
```

如果你在文本编辑器中查看，现在有一个 staticfiles 目录，其中有四个子目录：admin、css、images 和 js。第一个是 Django 管理应用的静态资源，其他三个是我们指定的。这就是为什么复制了 131 个文件。

## 7. Bootstrap

为你的网站编写自定义 CSS 是一个值得的目标，我建议所有软件开发者，甚至后端开发者，在某个时候都要尝试一下。但实际上，像 Bootstrap 这样的前端框架存在是有原因的：它们在开始新项目时为你节省了大量时间。除非你有专门的设计师合作，否则在网站的早期迭代中坚持使用框架。

Bootstrap 可以本地安装或通过 CDN 使用。后者是一种更简单的方法，所以我们将在本书中采用它。可以在这里找到说明，将 Bootstrap 编译的 CSS 和 JS 的缓存版本交付给我们的项目。

请注意，这里不包括 Bootstrap 的完整链接。你应该从 Bootstrap 网站复制并粘贴它们以确保准确性。它们在这里被称为 Bootstrap CSS 和 Bootstrap JavaScript。

```html
<!-- templates/_base.html -->

{% load static %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>{% block title %}书店{% endblock %}</title>
    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- CSS -->
    <link rel="stylesheet" href="{% static 'css/base.css' %}" />
  </head>
  <body>
    <div class="container">{% block content %} {% endblock content %}</div>
    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- JavaScript -->
    <script src="{% static 'js/base.js' %}"></script>
  </body>
</html>
```

请注意，这里 CSS 和 JavaScript 的顺序很重要。文件将从上到下加载，所以我们的 base.css 文件在 Bootstrap CSS 之后。这意味着我们的自定义 h1 样式将覆盖 Bootstrap 默认值。在文件底部，我们也将 base.js 文件放在 Bootstrap JavaScript 文件之后。

现在是实际使用 Bootstrap 的时候了。我们将从在<body>部分的顶部向\_base.html 文件添加固定导航栏开始。

```html
<!-- templates/_base.html -->

...

<body>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">书店</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#navbarCollapse"
        aria-controls="navbarCollapse"
        aria-expanded="false"
        aria-label="切换导航"
      >
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0">
          {% if user.is_authenticated %}
          <li class="nav-item">
            <a class="nav-link" href="{% url 'logout' %}">登出</a>
          </li>
          {% else %}
          <li class="nav-item">
            <a class="nav-link" href="{% url 'login' %}">登录</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="{% url 'signup' %}">注册</a>
          </li>
          {% endif %}
        </ul>
      </div>
    </div>
  </nav>
  <div class="container">{% block content %} ...</div>
</body>
```

另一个步骤是更新 base.css，以便我们的 body 部分适合新的导航栏。

**代码**

```css
/* static/css/base.css */
body {
  min-height: 75rem;
  padding-top: 4.5rem;
}

h1 {
  color: red;
}

img.bookcover {
  height: 300px;
  width: auto;
}
```

我们 home.html 模板中的代码现在也可以清理了。我们不需要显示登录或注册链接。我们也不需要显示关于用户未登录的消息。简化的 home.html 模板应该如下所示：

```html
<!-- templates/home.html -->

{% extends "_base.html" %} {% load static %} {% block title %}首页{% endblock
title %} {% block content %}

<h1>这是我们的主页。</h1>
<img class="bookcover" src="{% static 'images/dfp.jpg' %}" />
{% endblock content %}
```

现在刷新主页以查看我们的新导航栏和更新的主页。网页正文只显示标题和书籍封面。

如果你点击导航栏中的"登出"链接，它会自动更新为包含"登录"和"注册"。

## 8. 关于页面

现在让我们向我们的项目和导航栏添加一个关于页面。现在我们已经配置了网站的脚手架，这非常简单。由于这将是一个静态页面，我们不需要涉及数据库模型。但是我们需要一个模板、视图和 URL。

让我们首先创建一个名为 templates/about.html 的新模板文件。该页面现在将只说"关于页面"，同时从\_base.html 继承。

**代码**

```html
<!-- templates/about.html -->

{% extends "_base.html" %} {% block title %}关于{% endblock title %} {% block
content %}

<h1>关于页面</h1>
{% endblock content %}
```

视图可以依赖 Django 的内置 TemplateView，就像我们的主页一样。

```python
# pages/views.py

from django.views.generic import TemplateView

class HomePageView(TemplateView):
    template_name = "home.html"

class AboutPageView(TemplateView):  # 新增
    template_name = "about.html"
```

URL 路径也会很熟悉。在 pages/urls.py 文件中，我们将首先导入必要的视图 AboutPageView，创建一个新的 URL 路径到 about/，并提供一个名为 about 的 URL 名称。

```python
# pages/urls.py

from django.urls import path

from .views import HomePageView, AboutPageView  # 新增

urlpatterns = [
    path("about/", AboutPageView.as_view(), name="about"),  # 新增
    path("", HomePageView.as_view(), name="home"),
]
```

如果你现在访问 URL http://127.0.0.1:8000/about/，你可以看到关于页面。

**关于页面**

作为最后一步，更新导航栏中到页面的链接。因为我们在 URL 路径中提供了 about 的名称，这就是我们将与 url 模板标签一起使用的。在\_base.html 的第 18 行，将关于页面链接的行更改为以下内容：

**代码**

```html
<!-- templates/_base.html -->

...

<div class="collapse navbar-collapse" id="navbarCollapse">
  <ul class="navbar-nav me-auto mb-2 mb-md-0">
    <li class="nav-item">
      <a class="nav-link" href="{% url 'about' %}">关于</a>
    </li>
    {% if user.is_authenticated %} ...
  </ul>
</div>
```

如果你现在刷新关于页面，它将在导航栏中显示"关于"链接。

**关于导航栏链接**

到目前为止，本章中有很多代码，特别是在\_base.html 文件中。如果你担心小的拼写错误，完全可以查看这里的官方源代码，如果需要的话，只需复制并粘贴 templates/\_base.html 文件。

## 9. 关于页面测试

测试时间。我们添加了一个新的关于页面，所以我们应该在 pages/tests.py 中为它添加基本测试。这些测试将与我们之前为主页添加的测试非常相似。

**代码**

```python
# pages/tests.py

from django.test import SimpleTestCase
from django.urls import reverse, resolve

from .views import HomePageView, AboutPageView  # 新增

class HomepageTests(SimpleTestCase):
    ...

class AboutPageTests(SimpleTestCase):  # 新增
    def setUp(self):
        url = reverse("about")
        self.response = self.client.get(url)

    def test_aboutpage_status_code(self):
        self.assertEqual(self.response.status_code, 200)

    def test_aboutpage_template(self):
        self.assertTemplateUsed(self.response, "about.html")

    def test_aboutpage_contains_correct_html(self):
        self.assertContains(self.response, "关于页面")

    def test_aboutpage_does_not_contain_incorrect_html(self):
        self.assertNotContains(
            self.response, "你好！我不应该在页面上。")

    def test_aboutpage_url_resolves_aboutpageview(self):
        view = resolve("/about/")
        self.assertEqual(
            view.func.__name__,
            AboutPageView.as_view().__name__
        )
```

运行测试。

**Shell**

```bash
$ docker-compose exec web python manage.py test
找到15个测试。
为别名'default'创建测试数据库...
系统检查未发现问题（0个被忽略）。
...............

---

在0.161秒内运行了15个测试

确定
销毁别名'default'的测试数据库...
```

它们都通过了！很好。现在我们可以确信，我们对项目的任何未来更改都不会破坏关于页面。

## 10. Django Crispy Forms

在完成 Bootstrap 集成的最后一步，我们需要优化表单的显示效果。Django 原生的表单渲染功能相对基础，而第三方包 `django-crispy-forms` 为我们提供了强大的表单美化解决方案。这个包不仅能够自动应用 Bootstrap 样式，还提供了丰富的表单布局控制功能。

为了与我们使用的 Bootstrap 5 框架完美兼容，我们还需要安装专门的模板包 `crispy-bootstrap5`，它包含了针对 Bootstrap 5 优化的表单模板和样式。

让我们将这两个依赖包添加到项目的 `requirements.txt` 文件中：

**requirements.txt**

```
asgiref==3.5.2
Django==4.0.4
psycopg2-binary==2.9.3
sqlparse==0.4.2
django-crispy-forms==1.14.0
crispy-bootstrap5==0.6
```

然后停止我们的 Docker 容器并重建它，以便 django-crispy-forms 和 crispy-bootstrap5 可用。

**Shell**

```bash
$ docker-compose down
$ docker-compose up -d --build
```

我们的 Dockerfile 有一个命令来检查 requirements.txt，看看是否有任何更改，如果有，就在我们的 Docker 镜像中安装它，然后由我们的容器运行，如 docker-compose.yml 中所述。这是使用 Docker 时安装新包的安全方法。

安装后，我们必须将 django-crispy-forms 和 crispy_bootstrap5 添加到 INSTALLED_APPS 设置中。请注意，这里的应用名称需要是 crispy_forms！一个很好的附加功能是在 CRISPY_TEMPLATE_PACK 下指定 bootstrap5，这将为我们提供预样式化的表单。

```python
# django_project/settings.py

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # 第三方
    "crispy_forms",  # 新增
    "crispy_bootstrap5",  # 新增
    # 本地
    "accounts.apps.AccountsConfig",
    "pages.apps.PagesConfig",
]

# django-crispy-forms

CRISPY_ALLOWED_TEMPLATE_PACKS = "bootstrap5"  # 新增
CRISPY_TEMPLATE_PACK = "bootstrap5"  # 新增
```

要使用 Crispy Forms，我们在模板顶部加载 crispy_forms_tags，并添加{{ form|crispy }}来替换{{ form.as_p }}以显示表单字段。我们还将利用这个时间为提交按钮添加 Bootstrap 样式。

从 templates/registration/signup.html 文件开始，进行以下更新。

```html
<!-- templates/registration/signup.html -->

{% extends "_base.html" %} {% load crispy_forms_tags %} {% block title %}注册{%
endblock title %} {% block content %}

<h2>注册</h2>
<form method="post">
  {% csrf_token %} {{ form|crispy }}
  <button class="btn btn-success" type="submit">注册</button>
</form>
{% endblock content %}
```

然后导航到 http://127.0.0.1:8000/accounts/signup/ 的注册页面。

接下来也更新 templates/registration/login.html，在顶部添加 crispy_forms_tags，在表单中添加{{ form|crispy }}。

```html
<!-- templates/registration/login.html -->

{% extends "_base.html" %} {% load crispy_forms_tags %} {% block title %}登录{%
endblock title %} {% block content %}

<h2>登录</h2>
<form method="post">
  {% csrf_token %} {{ form|crispy }}
  <button class="btn btn-success" type="submit">登录</button>
</form>
{% endblock content %}
```

并导航到 http://127.0.0.1:8000/accounts/login/ 的登录页面。

## 11. Git

总结一下，我们应该总是为我们的工作做 Git 提交。检查本章中更改的状态，添加所有更改，然后提供提交消息。

```bash
$ git status
$ git add .
$ git commit -m 'ch7'
```

如往常一样，如果有任何问题，你可以将你的代码与 Github 上的官方代码进行比较。

## 12. 结论

静态资源是每个网站的核心部分，在 Django 中，我们必须采取许多额外步骤，以便它们在生产中得到有效编译和托管。我们还看到了向现有网站添加额外静态页面（如我们的关于页面）是多么容易。我们添加了 Bootstrap 和 django-crispy-forms 来改进我们网站和表单的样式。在本书的后面，我们将学习如何使用专用的内容分发网络（CDN）来托管和显示我们项目的静态文件。
