# 第 18 章：部署

到目前为止，我们一直完全在计算机上的本地开发环境中工作。但现在是时候部署我们的项目，使其可以被公众访问了。事实上，部署这个话题本身就值得写一整本书。与其他 Web 框架相比，Django 在这个话题上非常不干涉和不可知。大多数托管平台都没有一键部署功能，虽然这需要更多的开发者工作，但它也允许，以典型的 Django 方式，高度的定制化。

在上一章中，我们配置了一个完全独立的 docker-compose-prod.yml 文件，并更新了 django_project/settings.py 使其适合生产环境。在本章中，我们将回顾如何选择托管提供商，添加生产就绪的 Web 服务器，并在部署我们的书店网站之前正确配置静态/媒体文件！

## PaaS vs IaaS

首要考虑的问题是选择平台即服务（PaaS）还是基础设施即服务（IaaS）。PaaS 是一种预配置的托管解决方案，能够自动处理网站所需的大部分初始配置和扩展工作。典型代表包括 Heroku、PythonAnywhere 和 Dokku 等平台。尽管 PaaS 的前期成本相对较高，但它能够显著节省开发时间，自动处理安全更新，并支持快速扩展。

相比之下，IaaS 提供了更高的灵活性和更低的成本，但需要开发者具备丰富的知识和投入大量精力进行正确配置。主要的 IaaS 提供商包括 DigitalOcean、Linode、Amazon EC2 和 Google Compute Engine 等。

那么该如何选择呢？Django 开发者通常分为两类：一类是已经建立了完整 IaaS 部署流水线的开发者，另一类是倾向于使用 PaaS 的开发者。考虑到前者的复杂性和配置差异性，本书将采用 PaaS 方案，具体选择 Heroku 平台。

选择 Heroku 虽然带有一定的主观性，但它是一个技术成熟、稳定可靠的平台，提供的免费套餐完全能够满足我们书店项目的部署需求。

## WhiteNoise

我们已经看到，对于本地开发，Django 依赖 staticfiles 应用程序来为整个项目提供静态文件服务。这很方便，但效率很低，可能也不安全。

对于生产环境，必须运行 collectstatic 命令将所有静态文件编译到 STATIC_ROOT 指定的单个目录中。然后可以通过更新 STATICFILES_STORAGE 在同一服务器、单独的服务器或专用的云服务/CDN 上提供合并的文件。

在我们的项目中，我们将依靠 WhiteNoise 项目的帮助从我们的服务器提供文件，它在 Heroku 上工作得非常好，比 Django 默认设置更快、更可配置。要安装 whitenoise，我们将把它添加到 requirements.txt 文件中，停止容器，重建镜像，然后再次启动服务器。

**requirements.txt**

```
asgiref==3.5.2
Django==4.0.4
psycopg2-binary==2.9.3
sqlparse==0.4.2
django-crispy-forms==1.14.0
crispy-bootstrap5==0.6
django-allauth==0.50.0
environs[django]==9.5.0
pillow==9.0.1
django-debug-toolbar==3.4.0
whitenoise==6.1.0
```

然后停止我们的 Docker 容器。

**Shell**

```bash
$ docker-compose down
```

我们还不会重建镜像和重启容器，因为我们还必须首先对 django_project/settings.py 文件进行更改。由于我们使用 Docker，可以在本地和生产环境中都切换到 WhiteNoise。虽然可以通过向 runserver 命令传递--nostatic 标志来做到这一点，但在实践中这变得很累。更好的方法是在 INSTALLED_APPS 配置中在 django.contrib.staticfiles 之前添加 whitenoise.runserver_nostatic，这将做同样的事情。我们还将在 SecurityMiddleware 下面的 MIDDLEWARE 中添加它，并更新 STATICFILES_STORAGE 以现在使用 WhiteNoise。

```python
# django_project/settings.py

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "whitenoise.runserver_nostatic",  # new
    "django.contrib.staticfiles",
    "django.contrib.sites",
    ...
]

MIDDLEWARE = [
    "django.middleware.cache.UpdateCacheMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",  # new
    ...
]

STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"  # new
```

注意 STATICFILES_STORAGE 应该是一行。这里格式化为两行是为了适应书本格式。

完成所有更改后，我们现在可以在本地开发模式下再次启动我们的项目。

```bash
$ docker-compose up -d --build
```

WhiteNoise 有额外的选项来提供压缩内容和对不会改变的内容的远期缓存头。但现在，继续运行 collectstatic 命令。会有关于覆盖现有文件的警告。没关系。输入"yes"然后按"Return"键继续。

```bash
$ docker-compose exec web python manage.py collectstatic
...
140 static files copied to '/code/staticfiles', 2 unmodified, 404 post-processed.
```

## 媒体文件

不幸的是，媒体文件（如我们网站中的书籍封面）比静态文件稍微复杂一些，原因在第 13 章中有所涉及。因此，虽然它们在本地开发中会按预期显示，但在生产环境中不会保持很长时间。推荐的方法是使用非常流行的 django-storages 包以及像 S3 这样的专用 CDN。但是，这需要额外的配置，超出了本书的范围。

## Gunicorn

当我们在第 3 章中运行 startproject 命令时，创建了一个带有默认 WSGI（Web 服务器网关接口）配置的 django_project/wsgi.py 文件。这是 Web 应用程序（如我们的书店项目）如何与 Web 服务器通信的规范。

对于生产环境，通常将其替换为 Gunicorn 或 uWSGI。两者都提供性能提升，但 Gunicorn 更专注、更简单实现，所以它将是我们的选择。

首先将其添加到 requirements.txt 文件的底部。

**requirements.txt**

```
asgiref==3.5.2
Django==4.0.4
psycopg2-binary==2.9.3
sqlparse==0.4.2
django-crispy-forms==1.14.0
crispy-bootstrap5==0.6
django-allauth==0.50.0
environs[django]==9.5.0
pillow==9.0.1
django-debug-toolbar==3.4.0
whitenoise==6.1.0
gunicorn==20.1.0
```

因为我们使用 Docker，我们的本地环境可以很容易地模拟生产环境，所以我们将更新 docker-compose.yml 和 docker-compose-prod.yml 以使用 Gunicorn 而不是本地服务器。

**docker-compose.yml**

```yaml
# command: python /code/manage.py runserver 0.0.0.0:8000
command: gunicorn django_project.wsgi -b 0.0.0.0:8000 # new
```

**docker-compose-prod.yml**

```yaml
# command: python /code/manage.py runserver 0.0.0.0:8000
command: gunicorn django_project.wsgi -b 0.0.0.0:8000 # new
```

然后关闭我们的容器，重建新镜像，并重启容器。

**Shell**

```bash
$ docker-compose down
$ docker-compose up -d --build
```

## Heroku

前往 Heroku 网站并注册一个免费账户。确认您的电子邮件后，Heroku 将重定向您到网站的仪表板部分。

接下来确保安装 Heroku 的命令行界面（CLI），这样我们就可以从命令行部署。这里有详细的说明。

最后一步是通过在命令行输入 heroku login 来使用您的 Heroku 凭据登录。使用您刚刚设置的 Heroku 电子邮件和密码。

**Shell**

```bash
$ heroku login
Opening browser to https://cli-auth.heroku.com/auth/cli/browser/...
Logging in... done
Logged in as will@wsvincent.com
```

全部设置好了！如果您有任何问题，可以在命令行输入 heroku help 或访问 Heroku 网站获取更多信息。

## 使用 Docker 部署

由于我们在本地使用 Docker 容器，我们不妨在生产环境中也这样做。传统的非 Docker Heroku 依赖自定义 Procfile 来配置网站进行部署。对于容器，Heroku 依赖类似的方法，但它被称为 heroku.yml 文件。

现在在文本编辑器中在基础目录中创建 heroku.yml 文件。有四个顶级部分可用于配置：setup、build、release 和 run。

setup 的主要功能是指定需要哪些附加组件。这些是 Heroku 提供的托管解决方案，通常收费。最重要的是我们的数据库，它将依赖免费的 heroku-postgresql 层。Heroku 负责配置它、安全更新，我们可以根据需要轻松升级数据库大小和正常运行时间。

build 部分是我们指定如何构建 Dockerfile 的地方。这依赖于我们在根目录中的当前 Dockerfile。release 阶段用于在部署每个新版本之前运行任务。例如，我们可以确保 collectstatic 在每次部署时自动运行。最后是 run 阶段，我们指定实际运行应用程序的进程。值得注意的是，使用 Gunicorn 作为 Web 服务器。

**heroku.yml**

```yaml
setup:
  addons:
    - plan: heroku-postgresql
build:
  docker:
    web: Dockerfile
release:
  image: web
  command:
    - python manage.py collectstatic --noinput
run:
  web: gunicorn django_project.wsgi
```

确保将新的部署更新添加到 Git 并提交它们。在下一节中，我们将把所有本地代码推送到 Heroku 本身。

**Shell**

```bash
$ git status
$ git add .
$ git commit -m 'ch18'
```

## Heroku 部署

现在为我们的书店项目在 Heroku 上创建一个新应用程序。如果您输入 heroku create，它将分配一个随机名称。由于名称在 Heroku 中是全局的，像"blog"或"webapp"这样的常见名称不太可能可用。名称总是可以稍后在 Heroku 网站仪表板中更改为可用的全局命名空间。

**Shell**

```bash
$ heroku create
Creating app... done, ⬢ mysterious-hollows-62532
https://mysterious-hollows-62532.herokuapp.com/ |
https://git.heroku.com/mysterious-hollows-62532.git
```

在这种情况下，Heroku 为我的应用程序分配了名称 mysterious-hollows-62532。如果您刷新网站上的 Heroku 仪表板，您现在将看到新创建的应用程序。点击新应用程序打开"概述"页面。

下一步是从 docker-compose-prod.yml 添加我们的生产环境变量。点击页面顶部的"Settings"选项，然后点击"Reveal Config Vars"。因为我们在 django_project/settings.py 中大量使用默认值，所以在生产环境中只有一个值需要设置：DJANGO_SECRET_KEY。

现在设置堆栈以使用我们的 Docker 容器，而不是 Heroku 的默认 buildpack。在 heroku stack:set container -a 后面的命令末尾包含您的应用程序名称。

**Shell**

```bash
$ heroku stack:set container -a mysterious-hollows-62532
Setting stack to container... done
```

要确认此更改正确执行，刷新 Heroku 仪表板网页，并注意在 Settings 页面顶部的"App Information"下，"Stack"现在设置为"container"。这就是我们想要的。

在将我们的代码推送到 Heroku 之前，我们必须指定我们想要的托管 PostgreSQL 数据库。在我们的情况下，免费的 hobby-dev 层工作得很好；它总是可以在将来更新。

**Shell**

```bash
$ heroku addons:create heroku-postgresql:hobby-dev -a mysterious-hollows-62532
Creating heroku-postgresql:hobby-dev on ⬢ mysterious-hollows-62532... free
Database has been created and is available
! This database is empty. If upgrading, you can transfer
! data from another database with pg:copy
Created postgresql-vertical-87783 as DATABASE_URL
Use heroku addons:docs heroku-postgresql to view documentation
```

您注意到 DATABASE_URL 变量是如何自动创建的吗！这就是为什么我们不必将其设置为生产环境变量。很酷。

## ALLOWED_HOSTS

现在我们知道了生产网站的专用 URL，我们可以将其添加到我们的 django_project/settings.py 文件中。按如下方式更新 ALLOWED_HOSTS 的现有条目：

```python
# django_project/settings.py

ALLOWED_HOSTS = ["mysterious-hollows-62532.herokuapp.com", "localhost", "127.0.0.1"]  # new
```

然后创建一个新的 Git 提交来反映更改。

**Shell**

```bash
$ git status
$ git commit -m 'updated ALLOWED_HOSTS setting'
```

## 上线！

好的，我们准备好了！创建一个 Heroku 远程，这意味着我们代码的一个版本将存在于 Heroku 托管的服务器上。确保包含-a 和您的应用程序名称。然后将代码"推送"到 Heroku，这将导致构建我们的 Docker 镜像并运行容器。

**Shell**

```bash
$ heroku git:remote -a mysterious-hollows-62532
set git remote heroku to https://git.heroku.com/mysterious-hollows-62532.git
$ git push heroku main
...
remote: Waiting for release.... done.
To https://git.heroku.com/mysterious-hollows-62532.git
 * [new branch]      main -> main
```

初始推送可能需要一段时间才能完成。您可以通过点击 Heroku 仪表板上的"Activity"选项卡来查看活动进度。

我们的书店项目现在应该在线可用。请记住，虽然代码镜像我们自己的本地代码，但生产网站有自己的数据库，其中没有任何信息。要在其上运行命令，请在标准命令前添加 heroku run。例如，我们应该迁移我们的初始数据库，然后创建一个超级用户账户。

**Shell**

```bash
$ heroku run python manage.py migrate
$ heroku run python manage.py createsuperuser
```

有两种方法可以打开新部署的应用程序。从命令行，您可以输入 heroku open -a 和您的应用程序名称。或者您可以点击 Heroku 仪表板右上角的"Open app"按钮。

**Shell**

```bash
$ heroku open -a mysterious-hollows-62532
```

但是...啊！这是什么？重定向错误。欢迎来到部署的乐趣，这样的问题会一直出现。

## SECURE_PROXY_SSL_HEADER

一些调查发现问题与我们的 SECURE_SSL_REDIRECT 设置有关。Heroku 使用代理，所以我们必须找到正确的头并相应地更新 SECURE_PROXY_SSL_HEADER。

默认情况下它设置为 None，但由于我们确实信任 Heroku，我们可以将其更新为('HTTP_X_FORWARDED_PROTO', 'https')。此设置不会对本地开发造成伤害，所以我们将直接将其添加到 django_project/settings.py 文件中，如下所示：

**代码**

```python
# django_project/settings.py

SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")  # new
```

将这些更改提交到 Git 并将更新的代码推送到 Heroku。

**Shell**

```bash
$ git status
$ git commit -m 'secure_proxy_ssl_header and allowed_hosts update'
$ git push heroku main
```

构建完成后，刷新您网站的网页。就在那里！

## 生产数据库

新的 Web 开发者经常想知道为什么我们的新实时网站不模拟我们本地拥有的内容。书籍在哪里？评论在哪里？

这是因为我们的本地数据库和生产数据库是完全不同的东西。实时网站对包含我们 PostgreSQL 数据库和我们添加的信息的本地 Docker 容器一无所知。要模拟我们本地拥有的内容，您需要登录到您的实时生产网站的管理部分。然后添加您想要的任何用户、书籍、评论等。

请记住，如果您希望书籍封面（媒体文件）长期保留，需要配置 django-storages。

## Heroku 日志

在某个时候，您的部署中不可避免地会出现错误。当您这样做时，运行 heroku logs 来查看错误和信息日志并调试正在发生的事情。

希望这个部署过程是顺利的。但在实践中，即使使用像 Heroku 这样成熟的平台即服务，也很可能会出现问题。如果您看到错误页面，输入 heroku logs --tail，它显示信息和错误日志，来诊断问题。

Heroku 提供了大量的附加服务，收费后可以快速添加到任何网站。如果您为您的网站使用自定义域名，确保 SSL 对任何网站都是至关重要的。您需要在 Heroku 上使用付费层才能启用此功能。

## 结论

本章中有很多代码，所以如果您有任何错误，请检查 Github 上的官方源代码。

即使有像 Heroku 这样的现代平台即服务的所有优势，部署对许多开发者来说仍然是一个复杂且经常令人沮丧的任务。就个人而言，我希望我的 Web 应用程序"就是工作"。但许多工程师开始享受在性能、安全性和扩展方面工作的挑战。毕竟，在这个领域衡量改进要容易得多：页面加载时间是否减少了？网站正常运行时间是否改善了？安全性是否是最新的？解决这些问题往往比争论向网站本身添加哪个新功能感觉更有回报。
