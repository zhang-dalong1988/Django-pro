# 第 15 章：搜索功能

搜索是大多数网站的基本功能，尤其是像我们的书店这样的电子商务相关网站。在本章中，我们将学习如何使用表单和过滤器实现基本搜索。然后，我们将通过额外的逻辑改进它，并探讨在 Django 中深入实现搜索选项的方法。虽然我们的数据库中现在只有三本书，但这里的代码可以扩展到任意数量的书籍。

搜索功能由两部分组成：一个用于传递用户搜索查询的表单，以及一个基于该查询执行过滤的结果页面。确定"正确"的过滤器类型是搜索变得有趣且困难的地方。但首先，我们需要创建表单和搜索结果页面。

我们可以从任何一个开始，但我们将先配置过滤功能，然后再处理表单。

## 搜索结果页面

我们将从搜索结果页面开始。与所有 Django 页面一样，这意味着添加专用的 URL、视图和模板。实现顺序并不特别重要，但我们将按照这个顺序添加它们。

在`books/urls.py`中，添加一个带有 URL 名称`search_results`的`search/`路径，该路径使用名为`SearchResultsListView`的视图。

```python
# books/urls.py

from django.urls import path

from .views import BookListView, BookDetailView, SearchResultsListView # new

urlpatterns = [
    path("", BookListView.as_view(), name="book_list"),
    path("<uuid:pk>", BookDetailView.as_view(), name="book_detail"),
    path("search/", SearchResultsListView.as_view(),
        name="search_results"), # new
]
```

接下来是视图`SearchResultsListView`，目前它只是列出所有可用的书籍。这是使用`ListView`的理想选择。它的模板将被称为`search_results.html`，位于`templates/books/`目录中。唯一的新代码是`SearchResultsListView`，因为我们之前已经在文件顶部导入了`ListView`和`Book`模型。

```python
# books/views.py

...
class SearchResultsListView(ListView): # new
    model = Book
    context_object_name = "book_list"
    template_name = "books/search_results.html"
```

最后是在文本编辑器中创建我们的模板`templates/books/search_results.html`。目前，它将按标题、作者和价格列出所有可用的书籍。

```html
<!-- templates/books/search_results.html -->

{% extends "_base.html" %} {% block title %}搜索{% endblock title %} {% block
content %}

<h1>搜索结果</h1>
{% for book in book_list %}
<div>
  <h3><a href="{{ book.get_absolute_url }}">{{ book.title }}</a></h3>
  <p>作者: {{ book.author }}</p>
  <p>价格: $ {{ book.price }}</p>
</div>
{% endfor %} {% endblock content %}
```

如果你仍然登录到用户账户，现在请退出。搜索结果页面现在对所有用户都可用，地址为http://127.0.0.1:8000/books/search/。

就是这样！

## 基本过滤

在 Django 中，QuerySet 用于过滤数据库模型的结果。目前，我们的搜索结果页面不像搜索结果，因为它输出了 Book 模型的所有结果。最终，我们希望根据用户的搜索查询运行过滤器，但首先我们将尝试多种过滤选项。

事实证明，有多种方法可以自定义 queryset，包括通过模型本身的管理器，但为了简单起见，我们可以只用一行代码添加过滤器。所以让我们这样做！

我们可以覆盖 ListView 上的默认 queryset 属性，该属性默认显示所有结果。queryset 文档非常健全和详细，但通常使用 contains（区分大小写）或 icontains（不区分大小写）是很好的起点。我们将基于包含名称"beginners"的标题实现过滤器。

```python
# books/views.py

class SearchResultsListView(ListView):
    model = Book
    context_object_name = "book_list"
    template_name = "books/search_results.html"
    queryset = Book.objects.filter(title__icontains="beginners") # new
```

刷新搜索结果页面，现在只显示标题包含"beginners"的书籍。成功！

对于基本过滤，大多数情况下，内置的 queryset 方法 filter()、all()、get()或 exclude()就足够了。但是，还有一个非常强大和详细的 QuerySet API，值得进一步研究。

## Q 对象

使用 filter()很强大，甚至可以链接过滤器，例如搜索所有包含"beginners"和"django"的标题。但是，通常你会想要更复杂的查找，可以使用"OR"而不仅仅是"AND"；这时就需要使用 Q 对象。

这里有一个例子，我们设置过滤器来查找标题为"beginners"或"api"的结果。只需在文件顶部导入 Q，然后微调我们现有的查询即可。|符号表示"or"运算符。我们可以根据需要过滤任何可用字段：不仅是标题，还可以是作者或价格。

随着过滤器数量的增加，通过 get_queryset()分离 queryset 覆盖可能会有所帮助。这就是我们在这里要做的，但请注意，这种选择是可选的。

```python
# books/views.py

from django.db.models import Q # new
...

class SearchResultsListView(ListView):
    model = Book
    context_object_name = "book_list"
    template_name = "books/book_list.html"

    def get_queryset(self):  # new
        return Book.objects.filter(
            Q(title__icontains="beginners") | Q(title__icontains="api")
        )
```

刷新搜索结果页面以查看新结果。

现在让我们关注相应的搜索表单，这样我们就可以根据用户的搜索查询填充过滤器，而不是硬编码。

## 表单

从根本上说，Web 表单很简单：它通过 GET 或 POST 方法获取用户输入并将其发送到 URL。但在实践中，Web 的这种基本行为可能非常复杂。

第一个问题是发送表单数据：数据实际上去了哪里，以及我们如何处理它？更不用说每当我们允许用户向网站提交数据时，都会有许多安全问题。

表单发送的"方式"只有两种选择：通过 GET 或 POST HTTP 方法。

POST 将表单数据打包，对其进行传输编码，将其发送到服务器，然后接收响应。任何改变数据库状态的请求——创建、编辑或删除数据——都应该使用 POST。

GET 将表单数据打包成一个字符串，添加到目标 URL 中。GET 应该只用于不影响应用程序状态的请求，例如搜索，其中数据库中没有任何内容发生变化，基本上我们只是进行过滤列表视图。

如果你在访问 Google.com 后查看 URL，你会在实际的搜索结果页面 URL 中看到你的搜索查询。

有关更多信息，如果你不熟悉表单基础知识，Mozilla 有关于发送表单数据和表单数据验证的详细指南，值得查看。

## 搜索表单

现在让我们在导航栏中添加一个基本的搜索表单，使其在每个页面上都可用。这意味着更新`_base.html`模板，特别是在 if/else/elif 逻辑之后的`<ul></ul>`标签底部。

以下是更新后的代码，我们将在下面解释。

```html
<!-- templates/_base.html -->

...
{% endif %}
</ul>
<form class="d-flex" action="{% url 'search_results' %}" method="get">
    <input class="form-control me-2" type="search" name="q" placeholder="Search" aria-label="Search" >
    <button class="btn btn-outline-success" type="submit">搜索</button>
</form>

   </div>
 </div>
</nav>
```

我们添加了 HTML `<form>`标签，并使用 Bootstrap 的样式使它们看起来很好。action 指定表单提交后重定向用户的位置，即 URL 名为 search_results 的页面。与所有 URL 链接一样，这是页面的 URL 名称。然后我们指定所需的方法为 get 而不是 post。

表单的第二部分是包含用户搜索查询的输入。我们为其提供了一个变量名 q，该变量稍后将在 URL 中可见，并且在视图文件中也可用。我们使用 class 添加 Bootstrap 样式，指定输入类型为 text，添加一个 Placeholder，这是提示用户的默认文本。最后一部分，aria-label，是提供给屏幕阅读器用户的名称。可访问性是 Web 开发的重要组成部分，应该从一开始就考虑：在所有表单中包含 aria-labels！

最后，我们包含了一个"搜索"按钮，可以点击它来运行搜索查询。用户也可以按 Return 键来实现相同的结果。

导航到主页——或任何页面——新的搜索框出现在右上角。

尝试输入搜索，例如"hello"。按下 Return 键或点击"搜索"按钮后，你将被重定向到搜索结果页面。特别注意，URL 包含搜索查询/search/?q=hello。

但是结果没有改变！这是因为我们的 SearchResultsListView 仍然有之前的硬编码值。最后一步是获取用户的搜索查询，由 URL 中的 q 表示，并将其传递给实际的搜索过滤器。

```python
# books/views.py

class SearchResultsListView(ListView):
    model = Book
    context_object_name = "book_list"
    template_name = "books/search_results.html"

    def get_queryset(self): # new
        query = self.request.GET.get("q")
        return Book.objects.filter(
            Q(title__icontains=query) | Q(author__icontains=query)
        )
```

有什么变化？我们添加了一个 query 变量，它获取表单提交中 q 的值。然后更新我们的过滤器，在标题或作者字段上使用 query。就是这样！刷新搜索结果页面——它仍然有相同的 URL 和我们的查询——结果符合预期：在标题或作者中没有"hello"的结果。

返回主页，尝试新的搜索，例如"api"或"beginners"，以查看完整的搜索功能。

## Git

确保通过将新代码提交到 Git 来保存我们在本章中的当前工作。

```shell
$ git status
$ git add .
$ git commit -m 'ch15'
```

本章的官方源代码可在 Github 上获取。

## 结论

我们的基本搜索现在已经完成，但我们只是触及了潜在搜索优化的表面。例如，也许我们想在搜索表单中添加一个按钮，可以点击它来代替按 Return 键？或者更好的是包含表单验证。除了使用 AND 和 OR 进行过滤之外，如果我们想要 Google 质量的搜索，还有其他因素，比如相关性等等。

有几个具有增强功能的第三方包，如 django-watson 或 django-haystack，但是，鉴于我们使用的是 PostgreSQL 作为数据库，我们可以利用其全文搜索和其他内置于 Django 本身的功能。

最后一个选择是使用必须在单独服务器上运行的企业级解决方案，如 ElasticSearch（使用 Docker 并不是最困难的事情），或者依赖托管解决方案，如 Swiftype 或 Algolia。

在下一章中，我们将探索 Django 中可用的许多性能优化，为我们的 Bookstore 项目的最终部署做准备。
