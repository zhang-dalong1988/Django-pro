# 第 8 章：高级用户注册

到目前为止，我们已经实现了标准的 Django 用户注册功能。但在专业项目中，这通常只是起点。如果我们想要自定义一些功能呢？例如，Django 默认的用户名/邮箱/密码模式在现在看来有些过时了。现在更常见的做法是只需要邮箱/密码进行注册和登录。实际上，认证流程的每个部分——表单、邮件、页面——都可以根据需要进行自定义。

许多项目中的另一个主要因素是对社交认证的需求，即通过第三方服务（如 Google、Facebook 等）处理注册和登录。

我们可以从头开始实现自己的解决方案，但这存在一些明确的风险：用户注册是一个复杂的领域，有许多活动部件，这是一个我们真的不想犯安全错误的领域。

因此，许多专业的 Django 开发者依赖流行的第三方包 `django-allauth`。添加任何第三方包都应该谨慎，因为你正在向技术栈添加另一个依赖项。重要的是确保任何包都是最新的且经过充分测试的。幸运的是，`django-allauth` 两者兼备。

以一点点魔法为代价，它解决了所有这些问题，并使自定义变得更加容易。

## 1. django-allauth

我们将以通常的方式安装 `django-allauth`。首先将其添加到现有的 `requirements.txt` 文件中。

**requirements.txt**

```
asgiref==3.5.2
Django==4.0.4
psycopg2-binary==2.9.3
sqlparse==0.4.2
django-crispy-forms==1.14.0
crispy-bootstrap5==0.6
django-allauth==0.50.0
```

然后停止当前运行的 Docker 容器，重建我们的 Docker 镜像，并启动一个新容器。

**Shell**

```bash
$ docker-compose down
$ docker-compose up -d --build
```

我们的网站仍将像以前一样运行，因为我们还没有明确告诉 Django 关于这个新的 `django-allauth` 包。为此，我们需要更新 `django_project/settings.py` 文件中的 `INSTALLED_APPS` 配置，添加 Django 内置但可选的 sites 框架、allauth 及其 account 功能 `allauth.account`。

`django-allauth` 还需要更新 Django 的 `AUTHENTICATION_BACKENDS`。默认情况下，Django 包含 `ModelBackend`，这是在 Django 管理后台中通过用户名登录所需的。`django-allauth` 需要自己的额外后端 `AuthenticationBackend`，以便用户可以通过邮箱登录。

以下是 `django_project/settings.py` 文件中完整更新的样子。

**代码**

```python
# django_project/settings.py

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",  # 新增
    # 第三方
    "crispy_forms",
    "crispy_bootstrap5",
    "allauth",  # 新增
    "allauth.account",  # 新增
    # 本地
    "accounts.apps.AccountsConfig",
    "pages.apps.PagesConfig",
]

# django-allauth 配置

SITE_ID = 1  # 新增
```

## 2. AUTHENTICATION_BACKENDS

Django 为任何新项目创建的 `settings.py` 文件包含许多显式设置——我们在文件中已经看到的那些——以及更长的隐式设置列表，这些设置存在但不可见。这一开始可能会令人困惑。完整的设置配置列表可在[这里](https://docs.djangoproject.com/en/4.0/ref/settings/)找到。

一个例子是 `AUTHENTICATION_BACKENDS` 设置。在底层，Django 将其设置为 `'django.contrib.auth.backends.ModelBackend'`，当 Django 尝试验证用户时使用。我们可以将以下行添加到 `django_project/settings.py`，当前行为将保持不变：

```python
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
)
```

但是，对于 `django-allauth`，我们需要添加其特定的认证选项，这将允许我们稍后切换到使用邮箱登录。在你的 `django_project/settings.py` 文件底部添加以下部分：

**代码**

```python
# django_project/settings.py

# django-allauth 配置

SITE_ID = 1
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",  # 新增
)
```

## 3. EMAIL_BACKEND

另一个隐式设置的配置是 `EMAIL_BACKEND`。默认情况下，Django 会寻找配置的 SMTP 服务器来发送邮件。

`django-allauth` 会在用户成功注册后发送这样的邮件，我们可以并将在稍后自定义它，但由于我们还没有正确配置 SMTP 服务器，这将导致错误。

目前的解决方案是让 Django 将任何邮件输出到命令行控制台。因此，我们可以通过使用 console 而不是 smtp 来覆盖默认的隐式配置。在 `settings.py` 文件底部添加这个：

**代码**

```python
# django_project/settings.py

# django-allauth 配置

SITE_ID = 1
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
)
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"  # 新增
```

## 4. ACCOUNT_LOGOUT_REDIRECT

此时我们的配置还有一个微妙的更改要做。如果你再次查看配置页面，你会看到有一个 `ACCOUNT_LOGOUT_REDIRECT` 设置，默认为主页路径 `/`。

在我们当前的 `settings.py` 文件中，我们有以下两行重定向设置，通过其 URL 名称 "home" 指向主页。

```python
# django_project/settings.py

LOGIN_REDIRECT_URL = "home"
LOGOUT_REDIRECT_URL = "home"
```

问题是 `django-allauth` 的 `ACCOUNT_LOGOUT_REDIRECT` 实际上覆盖了内置的 `LOGOUT_REDIRECT_URL`，但由于它们都指向主页，这种变化可能不会立即显现。为了使我们的应用程序面向未来——因为也许我们不想总是在登出时重定向到主页——我们应该在这里明确登出重定向。

我们还可以将两个重定向行移到我们的 `django-allauth` 配置部分下。此时整个 `django-allauth` 配置部分应该如下所示。

```python
# django_project/settings.py

# django-allauth 配置

LOGIN_REDIRECT_URL = "home"
ACCOUNT_LOGOUT_REDIRECT = "home"  # 新增
SITE_ID = 1
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
)
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
```

鉴于我们对 `django_project/settings.py` 文件做了许多更改，现在让我们运行 migrate 来更新我们的数据库。

**Shell**

```bash
$ docker-compose exec web python manage.py migrate
Operations to perform:
  Apply all migrations: account, accounts, admin, auth, contenttypes, sessions, sites
Running migrations:
  Applying account.0001_initial... OK
  Applying account.0002_email_max_length... OK
  Applying sites.0001_initial... OK
  Applying sites.0002_alter_domain_unique... OK
```

## 5. URLs

我们还需要将内置的 auth 应用 URL 替换为 `django-allauth` 自己的 allauth 应用。不过，我们仍将使用相同的 `accounts/` URL 路径，但是，由于我们将使用 `django-allauth` 的模板和路由进行注册，我们也可以删除我们 accounts 应用的 URL 路径。

```python
# django_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django 管理后台
    path("admin/", admin.site.urls),
    # 用户管理
    path("accounts/", include("allauth.urls")),  # 新增
    # 本地应用
    path("", include("pages.urls")),
]
```

此时我们可以进一步删除 `accounts/urls.py` 和 `accounts/views.py`，这两个文件都是专门为我们手写的注册页面创建的，现在不再使用。

## 6. 模板

Django 的 auth 应用在 `templates/registration` 目录中查找模板，但 allauth 更喜欢它们位于 `templates/account` 目录中。所以我们将创建一个名为 `templates/account` 的新目录，然后将我们现有的 `login.html` 和 `signup.html` 模板复制到其中。

**Shell**

```bash
$ mkdir templates/account
$ mv templates/registration/login.html templates/account/login.html
$ mv templates/registration/signup.html templates/account/signup.html
```

这里很容易意外地在 account 后面加上 s，但不要这样做，否则你会得到错误。正确的目录是 `templates/account/`。

此时我们可以删除 `templates/registration` 目录，因为它不再需要。

**Shell**

```bash
$ rm -r templates/registration
```

`rm` 意味着删除，`-r` 意味着递归地执行，这在处理目录时是必要的。如果你想了解更多关于这个命令的信息，你可以输入 `man rm` 来阅读手册。

请注意，如果你看到包含 `rm -rf` 的命令——特别是 `sudo rm -rf`——请格外小心！用这个命令可能会擦除你的整台计算机。除非你 100% 确定结果是预期的，否则永远不要执行它。

最后一步是更新 `templates/_base.html` 中的 URL 链接，使用 `django-allauth` 的 URL 名称而不是 Django 的。我们通过添加 `account_` 前缀来做到这一点，所以 Django 的 'logout' 现在将是 'account_logout'，'login' 将是 'account_login'，signup 将是 'account_signup'。

```html
<!-- templates/_base.html -->

...

<ul class="navbar-nav me-auto mb-2 mb-md-0">
  <li class="nav-item">
    <a class="nav-link" href="{% url 'about' %}">关于</a>
  </li>
  {% if user.is_authenticated %}
  <li class="nav-item">
    <a class="nav-link" href="{% url 'account_logout' %}">登出</a>
  </li>
  {% else %}
  <li class="nav-item">
    <a class="nav-link" href="{% url 'account_login' %}">登录</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="{% url 'account_signup' %}">注册</a>
  </li>
  {% endif %}
</ul>
...
```

我们完成了！

## 7. 登录

刷新 http://127.0.0.1:8000 的主页，如果你已经登录则登出，然后点击"登录"链接。登录页面现在是更新的页面。

**登录页面**

注意新的"记住我"复选框选项。这是 `django-allauth` 提供的众多配置中的第一个。默认的 None 询问用户是否希望记住他们的会话，这样他们就不必再次登录。它也可以设置为 False 不记住或 True 总是记住。我们将选择 True，这是传统 Django 登录页面的工作方式。

在 `django_project/settings.py` 文件的 `# django-allauth config` 部分下添加新行。

**代码**

```python
# django_project/settings.py

# django-allauth 配置

...
ACCOUNT_SESSION_REMEMBER = True  # 新增
```

刷新"登录"页面，复选框消失了！

如果你用超级用户账户尝试登录表单，它会重定向回主页并显示欢迎消息。点击"登出"链接。

**登出页面**

`django-allauth` 不是直接让我们登出，而是有一个中间的 "登出" 页面，我们可以自定义它以匹配我们项目的其余部分。

## 8. 登出

我们现在将通过创建 `templates/account/logout.html` 文件来更新默认的登出模板以覆盖它。现在在你的文本编辑器中这样做。与我们的其他模板一样，它将扩展 `_base.html` 并在提交按钮上包含 Bootstrap 样式。

```html
<!-- templates/account/logout.html -->

{% extends "_base.html" %} {% load crispy_forms_tags %} {% block title %}登出{%
endblock %} {% block content %}

<h1>登出</h1>
<p>你确定要登出吗？</p>
<form method="post" action="{% url 'account_logout' %}">
  {% csrf_token %} {{ form|crispy }}
  <button class="btn btn-danger" type="submit">登出</button>
</form>
{% endblock content %}
```

继续刷新页面。

然后点击"登出"链接完成过程。

## 9. 注册

在我们网站的顶部，在导航栏中，点击"注册"链接，它具有 Bootstrap 和 `django-crispy-forms` 样式。

我们可以通过 `django-allauth` 进行的一个可选自定义是只要求输入一次密码。由于我们稍后会配置密码更改和重置选项，用户错误输入密码而被锁定在账户之外的风险较小。

如果你查看 `django-allauth` 配置选项，这个更改是一行代码。

```python
# django_project/settings.py

# django-allauth 配置

...
ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False  # 新增
```

刷新页面，表单将自动更新以删除额外的密码行。

现在创建一个新用户来确认一切正常。我们可以称用户为 testuser1 ，使用 testuser1@email.com 作为邮箱， testpass123 作为密码。提交后它会重定向你到主页。

记住我们如何配置邮件输出到控制台？`django-allauth` 在注册时自动发送邮件，我们可以通过输入 `docker-compose logs` 来查看。

```bash
$ docker-compose logs
...
web_1 | Content-Type: text/plain; charset="utf-8"
web_1 | MIME-Version: 1.0
web_1 | Content-Transfer-Encoding: 7bit
web_1 | Subject: [example.com] Please Confirm Your E-mail Address
web_1 | From: webmaster@localhost
web_1 | To: testuser@email.com
web_1 | Date: Tue, 17 May 2022 14:04:15 -0000
web_1 | Message-ID: <155266195771.15.17095643701553564393@cdab877c4af3>
web_1 |
web_1 | Hello from example.com!
web_1 |
web_1 | You're receiving this e-mail because user testuser1 has given yours as
an e-mail address to connect their account.
web_1 |
web_1 | To confirm this is correct, go to http://127.0.0.1:8000/accounts/
confirm-emailMQ:1h4oIn:GYETeK5dRClGjcgA8NbuOoyvafA/
web_1 |
web_1 | Thank you from example.com!
web_1 | example.com
web_1 | -----------------------------------------------------------------------
...
```

就在那里。在本书的后面，我们将自定义这条消息并配置适当的邮件服务将其发送给实际用户。

## 10. 管理后台

在 http://127.0.0.1:8000/admin/ 用你的超级用户账户登录管理后台，我们可以看到它也发生了变化，现在涉及到 `django-allauth`。

有两个新部分：Accounts 和 Sites，这是我们最近工作的结果。如果你点击 Users 部分，我们会看到显示三个当前用户账户的传统视图。

**管理后台用户**

如果你展开页面左侧的管理后台侧边栏，我们可以直接转到 Sites 部分，看看 Django sites 框架提供了什么。我们将在后面关于配置邮件的章节中更新域名和显示名称。

## 11. 仅邮箱登录

现在是真正使用 `django-allauth` 广泛配置列表的时候了，通过切换到仅使用邮箱登录，而不是用户名。这需要一些更改。首先我们将使用户名不是必需的，但将邮箱设置为必需的。然后我们将要求邮箱是唯一的，并且是首选的认证方法。

```python
# django_project/settings.py

# django-allauth 配置

...
ACCOUNT_USERNAME_REQUIRED = False  # 新增
ACCOUNT_AUTHENTICATION_METHOD = "email"  # 新增
ACCOUNT_EMAIL_REQUIRED = True  # 新增
ACCOUNT_UNIQUE_EMAIL = True  # 新增
```

导航回主页并点击"登出"，因为你将用超级用户账户登录。然后点击导航栏链接"注册"并为 testuser2@email.com 创建账户，密码为 testpass123 。

成功重定向到主页后，进入管理后台检查实际发生了什么。用你的超级用户账户登录并导航到 Users 部分。

我们可以看到 `django-allauth` 根据 @ 之前的邮箱部分自动为我们填充了用户名。这是因为我们底层的 CustomUser 模型仍然有用户名字段。我们没有删除它。

虽然这种方法可能看起来有点 hackish，但实际上它工作得很好。完全从自定义用户模型中删除用户名需要使用 `AbstractBaseUser`，这是一些开发者采取的额外可选步骤。它需要更多的编码和理解，所以除非你真的了解 Django 的认证系统，否则不建议这样做！

但是，这里有一个边缘情况我们应该研究：如果我们有 testuser2@email.com，然后注册 testuser2@example.com 会发生什么？这不会导致两者的用户名都是 testuser2，从而引起冲突吗？让我们试试看！

从管理后台登出，在注册页面为 testuser2@example.com 创建账户。

现在重新登录管理后台并转到我们的 Users 部分。

`django-allauth` 自动向用户名添加两位数字符串。在这种情况下是 20，所以 testuser2 变成 testuser20。这个两位数字符串将为我们随机生成。

## 12. 测试

测试时间。像任何好的第三方包一样，`django-allauth` 带有自己的测试，所以我们不需要重新测试其核心功能，只需确认我们的项目按预期工作。

不过，我们当前的测试现在有几个错误，与 SignUpPageTests 相关，因为我们现在使用 `django-allauth` 而不是我们自己的视图、表单和 URL。

让我们更新测试。从顶部开始，我们不再使用 CustomUserCreationForm 或 SignupPageView，所以我们可以删除这两个导入。我们现在使用 `django-allauth` 的 URL 路径和名称进行注册页面，即 account_signup，而不是我们之前命名的 signup。我怎么知道它是 account_signup？我查看了源代码并找到了 URL 名称。

更新的代码如下：

**代码**

```python
# accounts/tests.py

from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse, resolve

class CustomUserTests(TestCase):
    ...

class SignupPageTests(TestCase):  # 新增
    username = "newuser"
    email = "newuser@email.com"

    def setUp(self):
        url = reverse("account_signup")
        self.response = self.client.get(url)

    def test_signup_template(self):
        self.assertEqual(self.response.status_code, 200)
        self.assertTemplateUsed(self.response, "account/signup.html")
        self.assertContains(self.response, "Sign Up")
        self.assertNotContains(self.response, "Hi there! I should not be on the page.")

    def test_signup_form(self):
        new_user = get_user_model().objects.create_user(self.username, self.email)
        self.assertEqual(get_user_model().objects.all().count(), 1)
        self.assertEqual(get_user_model().objects.all()[0].username, self.username)
        self.assertEqual(get_user_model().objects.all()[0].email, self.email)
```

再次运行测试。

**Shell**

```bash
$ docker-compose exec web python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..............

----------------------------------------------------------------------
Ran 14 tests in 0.410s

OK
Destroying test database for alias 'default'...
```

## 13. 社交认证

如果你想添加社交认证，只需要几个设置。我有一个完整的在线教程来集成 Github。对于 Google、Facebook 和 `django-allauth` 支持的所有其他提供商，过程是类似的。这里是[完整的提供商列表](https://django-allauth.readthedocs.io/en/latest/providers.html)。

## 14. Git

像往常一样，用 Git 提交代码更改。

```bash
$ git status
$ git add .
$ git commit -m 'ch8'
```

如果有任何问题，请与 [Github 上的官方源代码](https://github.com/wsvincent/djangoforprofessionals)进行比较。

## 15. 结论

我们现在有一个有效的用户注册流程，如果需要，可以快速扩展到社交认证。在下一章中，我们将向我们的项目添加环境变量，以获得更大的安全性和灵活性。
