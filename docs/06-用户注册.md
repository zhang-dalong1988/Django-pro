# 第 6 章：用户注册

用户注册是任何动态网站的核心功能，我们的书店项目也不例外。在本章中，我们将实现登录、登出和注册功能。前两个功能相对简单，因为 Django 为我们提供了必要的视图和 URL，但注册功能更具挑战性，因为没有内置的解决方案。

## 1. 认证应用

让我们首先使用 Django 自带的认证应用来实现登录和登出功能。Django 为我们提供了必要的视图和 URL，这意味着我们只需要更新模板就能让功能正常工作。这为开发者节省了大量时间，并确保我们不会犯错，因为底层代码已经经过数百万开发者的测试和使用。

然而，这种简单性的代价是对 Django 新手来说感觉很"神奇"。我们在之前的书《Django for Beginners》中涵盖了其中一些步骤，但没有放慢脚步查看底层源代码。那本书演示了"如何"正确实现用户注册，但没有深入探讨"为什么"。

由于这是一本更高级的书，我们将深入了解底层源代码。这里的方法也可以用来自己探索任何其他内置的 Django 功能。

我们需要做的第一件事是确保认证应用包含在我们的`INSTALLED_APPS`设置中。我们之前在这里添加了自己的应用，但你是否仔细查看过 Django 自动为我们添加的内置应用？很可能答案是否定的。现在让我们来看看！

**代码**

```python
# django_project/settings.py

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",  # 就是这个！
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # 本地应用
    "accounts.apps.AccountsConfig",
    "pages.apps.PagesConfig",
]
```

实际上，Django 为我们提供了 6 个应用来驱动网站。第一个是 admin，第二个是 auth。这就是我们知道认证应用已经存在于 Django 项目中的原因。

当我们之前第一次运行 migrate 命令时，所有这些应用都在初始数据库中链接在一起。记住，我们使用了`AUTH_USER_MODEL`设置来告诉 Django 使用我们的自定义用户模型，而不是这里的默认 User 模型。这就是为什么我们必须等到该配置完成后才能第一次运行 migrate。

## 2. 认证 URL 和视图

要使用 Django 的内置认证应用，我们必须明确将其添加到我们的`config/urls.py`文件中。最简单的方法是使用`accounts/`作为前缀，因为这在 Django 社区中很常用。进行下面的一行更改。注意，随着我们的 urls.py 文件长度的增长，为每种类型的 URL 添加注释——admin、用户管理、本地应用等——有助于提高可读性。

```python
# django_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django管理
    path("admin/", admin.site.urls),
    # 用户管理
    path("accounts/", include("django.contrib.auth.urls")),  # 新增
    # 本地应用
    path("", include("pages.urls")),
]
```

认证应用包含什么？事实证明包含很多内容。首先，有许多相关的 URL。

```
accounts/login/ [name="login"]
accounts/logout/ [name="logout"]
accounts/password_change/ [name="password_change"]
accounts/password_change/done/ [name="password_change_done"]
accounts/password_reset/ [name="password_reset"]
accounts/password_reset/done/ [name="password_reset_done"]
accounts/reset/<uidb64>/<token>/ [name="password_reset_confirm"]
accounts/reset/done/ [name="password_reset_complete"]
```

我是怎么知道的？有两种方法。第一种是官方认证文档告诉我们的！但第二种更深入的方法是查看 GitHub 上可用的 Django 源代码。如果我们导航或搜索，我们会找到认证应用本身。在其中我们可以找到 urls.py 文件，该链接显示了完整的源代码。

理解 Django 源代码需要练习，但这是非常值得的。

## 3. 主页

接下来是什么？让我们更新现有的主页，以便它会通知我们用户是否已经登录，目前这只能通过管理员界面实现。

这是`templates/home.html`文件的新代码。它使用 Django 模板引擎的 if/else 标签进行基本逻辑处理。

**代码**

```html
<!-- templates/home.html -->

{% extends "_base.html" %} {% block title %}首页{% endblock title %} {% block
content %}
<h1>这是我们的主页。</h1>
{% if user.is_authenticated %}
<p>你好 {{ user.email }}！</p>
{% else %}
<p>你尚未登录</p>
<a href="{% url 'login' %}">登录</a>
{% endif %} {% endblock content %}
```

如果用户已登录（已认证），我们显示一个问候语，说"你好"并包含他们的电子邮件地址。这些都是我们可以通过双开`{{`和闭合`}}`括号在 Django 模板引擎中使用的变量。

默认的 User 包含许多字段，包括这里引用的`is_authenticated`和`email`。

而 logout 和 login 是 URL 名称。url 模板标签意味着如果我们指定 URL 名称，链接将自动引用该 URL 路径。例如，在上一章中，我们将主页的 URL 名称设置为 home，这意味着主页链接的格式为`{% url 'home' %}`。稍后会详细介绍。

如果你现在查看http://127.0.0.1:8000/的主页，它可能会显示你的超级用户账户的电子邮件地址，因为我们之前用它登录过。

在http://127.0.0.1:8000/admin/的管理界面中，如果你点击右上角的"注销"按钮，我们可以从管理界面注销，进而从Django项目注销。返回http://127.0.0.1:8000/的主页并刷新页面。

## 4. Django 源代码

你可能已经能够通过阅读官方文档自己拼凑出这些步骤。但更深入——也更好——的方法是学习如何自己阅读 Django 源代码。

一个问题是，用户及其相关变量是如何神奇地在我们的模板中可用的？答案是 Django 有一个叫做模板上下文的概念，这意味着每个模板都从相应的 views.py 文件加载数据。我们可以在模板标签中使用 user 来访问 User 属性。换句话说，Django 自动为我们提供了这个。

所以要检查用户是否已登录，我们访问 user，然后可以使用布尔值`is_authenticated`属性。如果用户已登录，它将返回 True，我们可以做一些事情，比如显示用户的电子邮件。或者如果没有用户登录，结果将是 False。

继续，我们有 URL 名称 login。这是从哪里来的？答案当然是来自 Django 本身！让我们逐个分解代码片段`{% url 'login' %}`。

首先，我们使用 url 模板标签，它以命名 URL 模式作为第一个参数。这是我们作为最佳实践添加到所有 URL 路径的可选名称部分。因此，Django 用于登录的 URL 必须附加一个'login'名称，对吧！

有两种方法我们可以知道这一点。换句话说，如果我没有告诉你我们想要使用`{% url 'login' %}`，你怎么能弄清楚呢？

首先查看官方文档。就我个人而言，我经常使用搜索功能，所以我会输入"login"之类的内容，然后点击直到找到登录的描述。我们想要的实际上叫做认证视图，并为我们列出了相应的 URL 模式。

**代码**

```
accounts/login/ [name="login"]
accounts/logout/ [name="logout"]
accounts/password_change/ [name="password_change"]
accounts/password_change/done/ [name="password_change_done"]
accounts/password_reset/ [name="password_reset"]
accounts/password_reset/done/ [name="password_reset_done"]
accounts/reset/<uidb64>/<token>/ [name="password_reset_confirm"]
accounts/reset/done/ [name="password_reset_complete"]
```

这告诉我们在路径`accounts/login/`是"login"所在的位置，其名称是'login'。起初有点令人困惑，但这里是我们需要的信息。

更深入到第二阶段，我们可以调查底层的 Django 源代码来看"logout"的实际操作。如果你在 GitHub 上执行搜索，你最终会找到认证应用本身。好的，现在让我们从调查 urls.py 文件开始。这里是完整代码的链接：

**代码**

```python
# django/contrib/auth/urls.py

from django.contrib.auth import views
from django.urls import path

urlpatterns = [
    path('login/', views.LoginView.as_view(), name='login'),
    path('logout/', views.LogoutView.as_view(), name='logout'),

    path('password_change/', views.PasswordChangeView.as_view(),
         name='password_change'),
    path('password_change/done/', views.PasswordChangeDoneView.as_view(),
         name='password_change_done'),
    path('password_reset/', views.PasswordResetView.as_view(),
         name='password_reset'),
    path('password_reset/done/', views.PasswordResetDoneView.as_view(),
         name='password_reset_done'),
    path('reset/<uidb64>/<token>/', views.PasswordResetConfirmView.as_view(),
         name='password_reset_confirm'),
    path('reset/done/', views.PasswordResetCompleteView.as_view(),
         name='password_reset_complete'),
]
```

这是 Django 本身用于认证应用的底层代码。我希望你能看到"logout"路由并不神奇。它就在那里，一目了然，它使用视图 LogoutView 并具有 URL 名称'logout'。一点也不神奇！只是第一次找到有点挑战性。

这个三步过程是学习的好方法：要么记住 Django 快捷方式，要么在文档中查找，或者偶尔深入源代码，真正理解所有这些好东西来自哪里。

## 5. 登录

回到我们的基本主页，点击"登录"链接，结果出现了错误！

Django 向我们抛出了一个 TemplateDoesNotExist 错误。具体来说，它似乎期望在`registration/login.html`有一个登录模板。除了 Django 告诉我们这一点，我们还可以查看文档，看到所需的 template_name 有那个位置。

但让我们真正确定并检查源代码，这样我们就可以消除这里任何感知的魔法。毕竟，这只是 Django。

回到 auth/views.py 文件，我们可以在第 47 行看到 LoginView 的 template_name 是'registration/login.html'。所以如果我们想改变默认位置，我们可以，但这意味着覆盖 LoginView，这似乎有点过度。让我们就使用 Django 在这里给我们的。

在现有的 templates 目录中创建一个新的 registration 文件夹。

**Shell**

```bash
$ mkdir templates/registration
```

然后在你的文本编辑器中在 templates/registration 目录中创建一个 login.html 文件。实际代码如下。我们扩展我们的基础模板，添加一个标题，然后指定我们想要使用一个将"post"或发送数据的表单。

**代码**

```html
<!-- templates/registration/login.html -->

{% extends "_base.html" %} {% block title %}登录{% endblock title %} {% block
content %}
<h2>登录</h2>
<form method="post">
  {% csrf_token %} {{ form.as_p }}
  <button type="submit">登录</button>
</form>
{% endblock content %}
```

你应该始终在任何可提交的表单上添加 CSRF 保护。否则，恶意网站可以更改链接并攻击网站和用户。Django 有 CSRF 中间件来为我们处理这个；我们需要做的就是在表单开始时添加`{% csrf_token %}`标签。

接下来我们可以控制表单内容的外观。现在我们将使用`as_p()`，这样每个表单字段都显示在段落 p 标签内。

解释完毕后，让我们检查我们的新模板是否正常工作。在http://127.0.0.1:8000/accounts/login/刷新网页。

现在有了我们的页面！很好。如果你愿意，你也可以导航回主页并确认"登录"链接有效。作为最后一步，继续尝试在登录页面上用你的超级用户账户登录。

## 6. 重定向

你注意到我在最后一句话中说"尝试"了吗？如果你点击"登录"链接，它会出现页面未找到(404)错误。

Django 将我们重定向到 127.0.0.1:8000/accounts/profile/，但没有这样的页面存在。现在 Django 为什么要这样做？好吧，如果你想想，Django 怎么知道我们想在登录后将用户重定向到哪里？也许是主页。但也许是用户资料页面。或者任何数量的选项。

登录拼图的最后一块是为 LOGIN_REDIRECT_URL 设置适当的配置，因为默认情况下它重定向到 accounts/profile。

幸运的是，这是一个快速修复。我们将把用户发送到我们的主页。由于我们指定了 home 的 URL 名称，这就是我们需要将登录用户重定向到主页的全部内容。

在 django_project/settings.py 文件的底部添加这一行。

**代码**

```python
# django_project/settings.py

LOGIN_REDIRECT_URL = "home"  # 新增
```

在http://127.0.0.1:8000/accounts/login/再次尝试登录。成功后，它将用户重定向到主页，问候你刚刚登录的超级用户账户！

## 7. 登出

现在让我们在主页上添加一个登出选项，因为只有超级用户才能访问管理界面。我们怎么做呢？

如果你查看上面的认证视图，我们可以看到 logout 使用 LogoutView，我们可以在源代码中探索，并且有一个 logout 的 URL 名称。这意味着我们可以用模板标签将其称为 logout。

但如果需要，我们可以自己设置这个，使用 LOGOUT_REDIRECT_URL，它可以添加到我们的 django_project/settings.py 文件的底部。让我们这样做，这样登出的用户被重定向到主页。

**代码**

```python
# django_project/settings.py

LOGIN_REDIRECT_URL = "home"
LOGOUT_REDIRECT_URL = "home"  # 新增
```

然后将登出链接添加到 templates/home.html。

**代码**

```html
<!-- templates/home.html -->

{% extends "_base.html" %} {% block title %}首页{% endblock title %} {% block
content %}
<h1>这是我们的主页。</h1>
{% if user.is_authenticated %}
<p>你好 {{ user.email }}！</p>
<p><a href="{% url 'logout' %}">登出</a></p>
{% else %}
<p>你尚未登录</p>
<a href="{% url 'login' %}">登录</a>
{% endif %} {% endblock content %}
```

在http://127.0.0.1:8000/刷新主页，"登出"链接现在可见。

如果你点击它，你将被登出并重定向到主页，其中"登录"链接可见。

## 8. 注册

实现用户注册的注册页面完全取决于我们。我们将经历任何新页面的标准步骤：

1. 创建应用级别的 accounts/urls.py 文件
2. 更新项目级别的 django_project/urls.py 以指向 accounts 应用
3. 添加一个名为 SignupPageView 的视图
4. 创建一个 signup.html 模板文件
5. 更新 home.html 以显示注册页面

一个常见的问题是：实现这些步骤的正确顺序是什么？老实说，这并不重要，因为我们需要所有这些才能让注册页面正常工作。我知道如果有一个规定的顺序会更令人安心，但每个都是一个拼图块，它们整体上拼合在一起。也就是说，我通常喜欢从 URL 开始，然后切换到视图，最后是模板，但这是个人偏好的问题。

首先使用你的文本编辑器创建一个 accounts/urls.py 文件。到目前为止，accounts 应用只在 models.py 文件中包含我们的 CustomUser；我们还没有配置任何路由或视图。

注册页面的 URL 路径将采用名为 SignupPageView 的视图（我们接下来将创建），在路由 signup/，并有一个 signup 的名称，我们稍后可以用 url 模板标签引用该页面。登录和注册的现有 url 名称写在我们上面看到的内置 Django 应用文件 django/contrib/auth/urls.py 中。

```python
# accounts/urls.py

from django.urls import path

from .views import SignupPageView

urlpatterns = [
    path("signup/", SignupPageView.as_view(), name="signup"),
]
```

接下来更新 django_project/urls.py 文件以包含 accounts 应用。我们可以创建任何我们喜欢的路由，但通常使用默认认证应用使用的相同 accounts/路由。注意，在下面包含 accounts.urls 的路径很重要：URL 路径是从上到下加载的，所以这确保任何内置的认证应用 URL 路径将首先加载。

**代码**

```python
# django_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django管理
    path("admin/", admin.site.urls),
    # 用户管理
    path("accounts/", include("django.contrib.auth.urls")),
    # 本地应用
    path("accounts/", include("accounts.urls")),  # 新增
    path("", include("pages.urls")),
]
```

现在创建视图 SignupPageView。它引用 CustomUserCreationForm 并有一个指向登录页面的 success_url，这意味着在提交表单后用户将被重定向到那里。template_name 将是 signup.html。

```python
# accounts/views.py

from django.urls import reverse_lazy
from django.views import generic

from .forms import CustomUserCreationForm

class SignupPageView(generic.CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy("login")
    template_name = "registration/signup.html"
```

作为最后一步，创建一个名为 templates/registration/signup.html 的文件，它将包含基本上与登录页面相同的代码。

```html
<!-- templates/registration/signup.html -->

{% extends "_base.html" %} {% block title %}注册{% endblock title %} {% block
content %}
<h2>Sign Up</h2>
<form method="post">
  {% csrf_token %} {{ form.as_p }}
  <button type="submit">Sign Up</button>
</form>
{% endblock content %}
```

作为最后一步，我们可以在"登录"链接下方的 home.html 模板中添加"注册"行。这是一行更改。

```html
<!-- templates/home.html -->
{% extends "_base.html" %} {% block title %}Home{% endblock title %} {% block
content %}
<h1>This is our homepage.</h1>
{% if user.is_authenticated %}
<p>Hello {{ user.email }}!</p>
<p><a href="{% url 'logout' %}">Logout</a></p>
{% else %}
<p>You are not logged in</p>
<a href="{% url 'login' %}">Login</a>
<a href="{% url 'signup' %}">Sign Up</a>
{% endif %} {% endblock content %}
```

全部完成！重新加载主页以查看我们的工作。

"注册"链接现在重定向到网页http://127.0.0.1:8000/accounts/signup/。

使用电子邮件地址testuser@email.com、用户名 testuser 和密码 testpass123 创建一个新用户。提交后，它将重定向我们到登录页面。使用新账户登录，它重定向到主页，并有个性化的问候语。

## 9. 测试

对于测试，我们不需要测试登录和登出功能，因为这些是内置在 Django 中的，并且已经有测试。但我们确实需要测试我们的注册功能！

让我们首先创建一个加载我们页面的 setUpTestClass 方法。然后我们将用状态码、使用的模板以及包含和排除的文本的测试填充 test_signup_template，类似于我们在上一章中为主页所做的。

在你的文本编辑器中，用这些更改更新 accounts/tests.py 文件。

**代码**

```python
# accounts/tests.py

from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse  # 新增

class CustomUserTests(TestCase):
    ...

class SignUpPageTests(TestCase):  # 新增
    def setUp(self):
        url = reverse("signup")
        self.response = self.client.get(url)

    def test_signup_template(self):
        self.assertEqual(self.response.status_code, 200)
        self.assertTemplateUsed(self.response, "registration/signup.html")
        self.assertContains(self.response, "注册")
        self.assertNotContains(self.response, "你好！我不应该在页面上。")
```

然后运行我们的测试。

**Shell**

```bash
$ docker-compose exec web python manage.py test
创建别名'default'的测试数据库...
系统检查未发现问题（0个被忽略）。
........

---

在0.148秒内运行了8个测试

确定
销毁别名'default'的测试数据库...
```

接下来我们可以测试我们的 CustomUserCreationForm 正在被使用，并且页面解析为 SignupPageView。

**代码**

```python
# accounts/tests.py

from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse, resolve  # 新增

from .forms import CustomUserCreationForm  # 新增
from .views import SignupPageView  # 新增

class CustomUserTests(TestCase):
    ...

class SignUpPageTests(TestCase):  # 新增
    def setUp(self):
        url = reverse("signup")
        self.response = self.client.get(url)

    def test_signup_template(self):
        self.assertEqual(self.response.status_code, 200)
        self.assertTemplateUsed(self.response, "registration/signup.html")
        self.assertContains(self.response, "注册")
        self.assertNotContains(self.response, "你好！我不应该在页面上。")

    def test_signup_form(self):  # 新增
        form = self.response.context.get("form")
        self.assertIsInstance(form, CustomUserCreationForm)
        self.assertContains(self.response, "csrfmiddlewaretoken")

    def test_signup_view(self):  # 新增
        view = resolve("/accounts/signup/")
        self.assertEqual(view.func.__name__, SignupPageView.as_view().__name__)
```

再次运行我们的测试。

**Shell**

```bash
$ docker-compose exec web python manage.py test
创建别名'default'的测试数据库...
系统检查未发现问题（0个被忽略）。
..........

---

在0.155秒内运行了10个测试

确定
销毁别名'default'的测试数据库...
```

全部完成。

## 10. Git

一如既往，确保通过将更改添加到 Git 中来保存我们的工作。

**Shell**

```bash
$ git status
$ git add .
$ git commit -m 'ch6'
```

如果你想比较你的代码，官方源代码位于 GitHub 上。

## 11. 结论

我们的书店项目不是世界上最美丽的网站，但在这一点上它非常实用。在下一章中，我们将配置我们的静态资源并添加 Bootstrap 以改进样式。
