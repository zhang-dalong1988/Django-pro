# 第 16 章：性能

任何网站的首要任务都是确保功能正常运行并具备完善的测试。然而，当你的项目有幸获得大量流量时，关注点就会迅速转向性能优化，力求最大化运行效率。这对许多工程师来说既是一个有趣的挑战，也可能成为一个陷阱。

计算机科学家 Donald Knuth 有一句著名的话值得我们深思：

"真正的问题在于，程序员总是在错误的时间和错误的地方过分担心效率问题；过早优化是编程中万恶之源（或至少是大部分问题的根源）。"

虽然建立适当的监控机制以便后续优化项目非常重要，但切勿在项目初期过分专注于此。我们无法在本地环境中完全模拟生产环境的真实情况，也无法准确预测网站的实际流量模式。在早期阶段，与其花费大量时间追求微小的性能提升，不如多与用户沟通，进行更有意义的代码改进！

本章将重点介绍 Django 性能优化的核心方向，并重点讲解在项目规模化过程中值得深入研究的关键领域。总的来说，性能优化主要涉及四个核心领域：数据库查询优化、缓存机制、索引策略以及前端资源压缩（包括图像、JavaScript 和 CSS 文件）。

## django-debug-toolbar

在我们优化数据库查询之前，我们需要看到它们。Django 社区中的首选工具是第三方包 django-debug-toolbar。它带有一组可配置的面板来检查任何给定页面的完整请求/响应周期。

按照惯例，我们可以通过将最新版本添加到我们的 requirements.txt 文件来安装它。

**requirements.txt**

```
asgiref==3.5.2
Django==4.0.4
psycopg2-binary==2.9.3
sqlparse==0.4.2
django-crispy-forms==1.14.0
crispy-bootstrap5==0.6
django-allauth==0.50.0
environs[django]==9.5.0
pillow==9.0.1
django-debug-toolbar==3.4.0
```

然后停止我们的容器，重建镜像，并再次运行容器。

**Shell**

```shell
$ docker-compose down
$ docker-compose up -d --build
```

在我们的 django_project/settings.py 文件中需要设置三个单独的配置：

- INSTALLED_APPS
- Middleware
- INTERNAL_IPS

首先将 Debug Toolbar 添加到 INSTALLED_APPS 配置中。请注意，正确的名称是 debug_toolbar，而不是可能预期的 django_debug_toolbar。

```python
# django_project/settings.py

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",
    # Third-party
    "crispy_forms",
    "crispy_bootstrap5",
    "allauth",
    "allauth.account",
    "debug_toolbar", # new
    # Local
    "accounts.apps.AccountsConfig",
    "pages.apps.PagesConfig",
    "books.apps.BooksConfig",
]
```

其次，将 Debug Toolbar 添加到主要实现它的 Middleware 中。

```python
# django_project/settings.py

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "debug_toolbar.middleware.DebugToolbarMiddleware", # new
]
```

第三，也要设置 INTERNAL_IPS。如果我们不在 Docker 中，这可以设置为 '127.0.0.1'，但是，由于我们在 Docker 中运行 Web 服务器，需要额外的步骤以便它与 Docker 的机器地址匹配。在 config/settings.py 的底部添加以下行。

```python
# django_project/settings.py

...

# django-debug-toolbar

import socket

hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
INTERNAL_IPS = [ip[:-1] + "1" for ip in ips]
```

这段代码看起来比较复杂，但它的作用是确保我们的 INTERNAL_IPS 设置与 Docker 主机地址保持一致。

最后一步是更新 URLconf 配置。为了确保 Debug Toolbar 仅在调试模式下显示，我们需要在 django_project/urls.py 文件底部添加条件判断逻辑，只有当 DEBUG 为 True 时才启用相关路由。

```python
# django_project/urls.py

...
if settings.DEBUG: # new
    import debug_toolbar

    urlpatterns = [
        path("__debug__/", include(debug_toolbar.urls)),
    ] + urlpatterns
```

现在如果你刷新主页，你会在右侧看到 django-debug-toolbar。

如果你点击顶部的"Hide"链接，它会变成页面右侧的一个更小的侧边栏。

## 分析页面

Debug Toolbar 有许多可能的自定义选项，但默认设置可见的内容告诉我们很多关于主页的信息。例如，我们可以看到正在使用的 Django 的当前版本以及加载页面所花费的时间。

然而，可能最有用的项目是 SQL，它显示特定页面上的查询。如果你现在已退出登录，主页上没有 SQL 查询。所以请继续使用你的超级用户账户登录，然后返回主页。Debug Toolbar 显示为登录用户运行了两个查询。

在 Django for Professionals 书籍页面上运行了六个查询：

- 会话框架来管理用户
- 到 accounts_customuser 来加载我们的用户
- 到 books_book 来加载"Django for Professionals"书籍
- 到 books_review 来加载评论
- 然后再有 2 个查询到 accounts_customuser

六个查询似乎不算太糟糕。但是如果我们有很多书籍评论会怎样？进入管理员并转到"Django for Professionals"书籍的条目。再添加八个评论——全部由 testuser 添加——这样现在总共有十个，然后点击"保存"。

你认为现在这本书的详细页面会有多少 SQL 查询？让我们过去看看！

正如可能预期的那样，现在有八个更多的查询与八个新评论相对应，意味着这一页总共有 14 个查询。

如果你查看 Django Debug Toolbar 中的 SQL 详细视图，它实际上在标记重复查询方面非常有帮助。真的有必要调用 accounts_customuser 十一次吗？有可能减少查询数量，因为毕竟，books 查询设法只用一个查询就导入了三本书。

我们现在遇到的是一个非常常见的问题，通常被称为"N+1 查询问题"。有几个第三方包可以帮助识别这个问题。幸运的是有工具可以帮助。

## select_related 和 prefetch_related

减少 SQL 查询是优化 Django 项目的关键步骤之一。Django ORM 提供了两个强大的方法来帮助我们实现这一目标，它们通过创建单个复杂的 QuerySet 来替代多个小查询，从而显著提升性能：

- `select_related` 用于外键关系
- `prefetch_related()` 用于多对多关系

`select_related` 返回一个"跟随"外键关系的 QuerySet——无论是一对一还是一对多关系——它会根据需要选择额外的相关对象数据。在底层实现中，Django ORM 创建一个 SQL 连接查询，并在 SELECT 语句中包含相关对象的字段，从而将所有相关对象包含在单个复杂的数据库查询中。

`prefetch_related` 则为每个关系执行单独的查找，并使用 Python 而非 SQL 将它们"连接"在一起。这使得它能够预取多对多和多对一对象，而这些是 `select_related` 无法处理的。

乍一看，这里的问题似乎是外键关系问题，应该使用 `select_related`。但实际上这是一个作者到评论的多对多关系问题，因为对于一篇文章，可能存在多个作者的多条评论。

深入理解 QuerySets 对于中级到高级 Django 开发人员来说至关重要。Django 提供了众多内置方法，理解 QuerySets 的构建方式、它们的唯一性以及惰性求值特性，能够为性能优化提供重要洞察。

我们可以直接通过命令行访问 Python shell 来探索当前的 QuerySets。启动 shell 后，首先需要从 books 应用中导入 Book 模型，然后查询所有数据来查看我们的三本书。

```shell
$ docker-compose exec web python manage.py shell

>>> from books.models import Book
>>> Book.objects.all()
<QuerySet [<Book: Django for APIs>, <Book: Django for Beginners>, <Book: Django for Professionals>]>
```

我们现在想只查看"Professionals"书籍。如果我们依赖每本书的默认 id，我们可以简单地使用 get() 方法，但由于我们使用 UUID，我们将改用 contains() 方法并将结果存储为名为 pros 的变量。最后，我们可以查看存储在其上的所有评论。

```shell
>>> pros = Book.objects.get(title__contains="Professionals")
>>> pros
<Book: Django for Professionals>
>>> pros.reviews.all()
<QuerySet [<Review: 1>, <Review: 2>, <Review: 3>, <Review: 4>, <Review: 5>, <Review: 6>, <Review: 7>, <Review: 8>, <Review: 9>, <Review: 10>]>
```

一个非常有用的第三方包是 django-extensions，它带有许多 Django 命令扩展。其中包括 shell_plus，它会自动在 shell 中加载所有应用模型。这可以在 Django 项目的生命周期中节省大量时间，并使使用 Django ORM 变得更加容易。但现在，我们可以通过键入 Ctrl + d 退出 Django shell。

默认情况下，DetailView 将返回调用 all() 方法的查询集。换句话说，Book.objects.all()。我们想要更新这个以一次性 prefetch_related 每个作者的所有评论。以下是我们的 books/views.py 文件中更新的样子。

```python
# books/views.py

...
class BookDetailView(
    LoginRequiredMixin, PermissionRequiredMixin, DetailView
):
    model = Book
    context_object_name = "book"
    template_name = "books/book_detail.html"
    login_url = "account_login"
    permission_required = "books.special_status"
    queryset = Book.objects.all().prefetch_related('reviews__author',) # new
```

这里的双下划线是一个查找，通常用于过滤 QuerySets。

如果我们现在刷新"Professionals"书籍的网页，django-debug-toolbar 显示我们已经将 SQL 查询从 14 个减少到 5 个！这是有道理的，因为我们现在一次性完成，而不是为每个评论和作者进行 10 个不同的查询（假设所有评论都是由同一作者撰写的）。

## 索引

索引是加速数据库性能的常用技术。它是一个单独的数据结构，允许更快的搜索，通常只应用于模型中的主键。缺点是索引需要磁盘上的额外空间，因此必须谨慎使用。

虽然从一开始就简单地向主键添加索引很诱人，但最好从不使用它们开始，只根据生产需求稍后添加它们。一般的经验法则是，如果给定字段被频繁使用，例如所有查询的 10-25%，它就是被索引的主要候选者。

历史上，可以通过向任何模型字段添加 db_index=True 来创建索引字段。例如，如果我们想向 Book 模型中的 id 字段添加一个，它会如下所示（但实际上不要实现这个）。

```python
# books/models.py

...
class Book(models.Model):
    id = models.UUIDField(
        primary_key=True,
        db_index=True, # new
        default=uuid.uuid4,
        editable=False)
    ...
```

这个更改需要通过迁移文件添加并迁移。

从 Django 1.11 开始，添加了基于类的模型索引，因此可以在 Meta 部分中包含。所以你可以改为如下编写之前的索引：

```python
# books/models.py

...
class Book(models.Model):
    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False)
    ...

    class Meta:
        indexes = [  # new
            models.Index(fields=["id"], name="id_index"),
        ]
        permissions = [
            ("special_status", "Can read all books"),
        ]
```

由于我们已经更改了模型，我们必须创建一个迁移文件并应用它。

```shell
$ docker-compose exec web python manage.py makemigrations books
Migrations for 'books':
  books/migrations/0005_book_id_index.py
    - Create index id_index on field(s) id of model book
$ docker-compose exec web python manage.py migrate
Operations to perform:
  Apply all migrations: account, accounts, admin, auth, books, contenttypes, sessions, sites
Running migrations:
  Applying books.0005_book_id_index... OK
```

## 缓存

缓存是将昂贵计算结果存储在内存中的技术。一旦计算完成，就无需重复执行！

考虑我们的书店项目作为一个动态网站。每当用户请求页面时，服务器必须执行各种计算操作，包括数据库查询、模板渲染等，然后才能提供服务。这个过程需要时间，相比从内容不变的静态站点直接读取文件要慢得多。

然而，在大型网站中，这种类型的开销可能会显著影响性能，缓存是 Web 开发人员工具包中的重要解决方案之一。虽然在我们当前的项目中实现缓存可能有些过度，但我们仍将回顾可用选项并实现一个基本版本。

Django 拥有自己的缓存框架，提供四种不同的缓存选项，按粒度递减顺序排列：

1. **每站点缓存**：最简单的设置方式，缓存整个站点。
2. **每视图缓存**：允许你缓存单个视图。
3. **模板片段缓存**：允许你指定模板的特定部分进行缓存。
4. **低级缓存 API**：允许你手动设置、检索和维护缓存中的特定对象。

为什么不持续缓存所有内容？主要有两个重要原因。首先，缓存内存成本昂贵，因为它以 RAM 形式存储。想想你笔记本电脑上从 8GB 升级到 16GB RAM 的成本，与从 256GB 升级到 512GB 硬盘空间的成本对比！其次，缓存必须保持"热"状态，即填充最新的内容，因此根据网站需求优化缓存以确保准确性而不浪费资源，需要进行大量调整。

如果你想实现每站点缓存（这是最简单的方法），需要在 `django_project/settings.py` 的 `MIDDLEWARE` 配置中，在最顶部添加 `UpdateCacheMiddleware`，在最底部添加 `FetchFromCacheMiddleware`。同时还需要设置三个额外的配置字段：`CACHE_MIDDLEWARE_ALIAS`、`CACHE_MIDDLEWARE_SECONDS` 和 `CACHE_MIDDLEWARE_KEY_PREFIX`。

```python
# django_project/settings.py

MIDDLEWARE = [
    "django.middleware.cache.UpdateCacheMiddleware", # new
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "django.middleware.cache.FetchFromCacheMiddleware", # new
]

CACHE_MIDDLEWARE_ALIAS = "default"
CACHE_MIDDLEWARE_SECONDS = 604800
CACHE_MIDDLEWARE_KEY_PREFIX = ""
```

你可能需要调整的唯一默认值是 `CACHE_MIDDLEWARE_SECONDS`，它设置缓存页面的默认秒数（600 秒）。超过这个时间后，缓存将过期并被清空。对于内容更新不频繁的网站，一个较好的初始默认值是 604800 秒，即 1 周（60 秒 × 60 分钟 × 168 小时）。但如果你发现缓存快速填满，或者网站内容更新频繁，缩短这个设置是一个不错的优化起点。

不过，在当前阶段实现缓存完全是可选的。一旦网站正式上线运行，对缓存的具体需求——无论是每站点缓存、每页面缓存等——将会很快显现出来。随着网站规模的扩大，使用专用的独立缓存服务器通常是明智的选择。最受欢迎的两个选项是 Redis 和 Memcached，从 Django 4.0 开始，这两者都获得了 Django 的内置支持。

## 前端资源

网站中另一个主要的瓶颈来源是加载前端资源。CSS 和 JavaScript 可能变得相当大，因此像 django-compressor 这样的工具可以帮助最小化它们的大小。

图像通常是资源大小方面首先要查看的地方。我们现有的静态/媒体文件设置将扩展到相当大的规模，但对于真正大型的网站，值得研究使用内容分发网络（CDN）来处理图像，而不是将它们存储在服务器文件系统上。

你也可以向用户提供不同大小的图像。例如，与其为列表或搜索页面缩小大型书籍封面，你可以存储一个较小的缩略图版本，并在需要时提供它。第三方 easy-thumbnails 包是一个很好的起点。

关于这个主题的一本很棒的免费电子书是 Addy Osmani 的《Essential Image Optimization》，它深入探讨了图像优化和自动化。

作为最终检查，有针对前端速度的自动化测试，如 Google 的 PageSpeed Insights，它将根据页面加载速度分配分数。

## 下一步

### Git

本章中有很多代码更改，所以确保用 Git 提交所有内容。

**Shell**

```shell
$ git status
$ git add .
$ git commit -m 'ch16'
```

如果你有任何错误，确保使用 docker-compose logs 查看你的日志，并将你的代码与 Github 上的官方源代码进行比较。

## 结论

可以应用于项目的性能优化几乎有无穷无尽的列表。但要注意回忆 Donald Knuth 的明智建议，不要在这方面过于疯狂。瓶颈将在生产中显现，应该主要在那时解决；而不是提前。还有几个第三方包可以帮助识别 N+1 问题，最值得注意的是 nplusone、django-zen-queries 和 django-auto-prefetch。

你应该记住，性能问题是一个好问题！它们是可以修复的，意味着你的项目被大量使用，这远比拥有一个完全优化但基本被忽略的网站要好。
