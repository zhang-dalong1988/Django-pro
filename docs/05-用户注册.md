# 用户注册

用户注册功能是任何动态网站的核心组成部分。我们的 Bookstore 项目自然也需要这一功能。本章将带领您实现三个关键的用户认证功能：登录、注销和注册。其中，登录和注销相对容易实现，因为 Django 框架已经为我们提供了现成的视图和 URL 配置。然而，注册功能则需要我们投入更多精力，这是因为 Django 并没有为此提供开箱即用的解决方案。

## 1. Auth 应用

让我们首先利用 Django 内置的[auth](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/)应用来实现登录和注销功能。Django 已经为我们准备好了必要的视图和 URL 配置，我们只需专注于模板部分即可。这种设计不仅大大提高了开发效率，还确保了代码的可靠性，因为这些底层实现已经经过了全球数百万开发者的实际检验。

不过，这种便捷性也让许多 Django 初学者感到有些"神奇"，难以理解其内部运作机制。在我之前的著作[Django for Beginners](https://djangoforbeginners.com)中，我们介绍了实现步骤，但没有深入剖析底层源码。那本书主要回答了"如何"实现用户注册的问题，而没有详细解释"为什么"。

作为一本进阶指南，本书将带您深入探索底层源码的工作原理。这种探索方法同样适用于研究 Django 的其他内置功能，帮助您真正掌握框架的精髓。

首先，我们需要确认`auth`应用是否已包含在我们的`INSTALLED_APPS`配置中。虽然我们之前已经添加了自己开发的应用，但您可能没有特别注意 Django 默认为我们配置的那些内置应用。现在，让我们仔细检查一下！

```python
# django_project/settings.py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",  # 这里！
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # 本地应用
    "accounts.apps.AccountsConfig",
    "pages.apps.PagesConfig",
]
```

实际上，Django 已经为我们预先配置了 6 个核心应用来支持网站的基本功能。其中，`admin`是第一个，而`auth`是第二个。这清晰地表明`auth`应用已经内置于我们的 Django 项目中，无需额外安装。

当我们初次执行`migrate`命令时，这些应用会自动在数据库中创建必要的表结构并建立关联。您还记得我们如何通过`AUTH_USER_MODEL`设置指示 Django 使用我们的自定义用户模型，而非其默认提供的`User`模型吗？正是因为这个原因，我们必须确保完成该配置后才能首次运行`migrate`命令，以避免数据库结构与用户模型不匹配的问题。

## Auth URLs 和 Views

要使用 Django 内置的`auth`应用，我们需要将其明确地添加到项目的`django_project/urls.py`文件中。在 Django 社区中，通常使用`accounts/`作为用户认证相关功能的 URL 前缀，这已成为一种广泛接受的惯例。我们只需添加一行代码即可完成配置。随着项目规模扩大，URL 配置文件会变得越来越复杂，此时为不同类型的 URL 路径（如管理后台、用户管理、本地应用等）添加清晰的注释，将大大提高代码的可读性和可维护性。

```python
# django_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django 管理
    path("admin/", admin.site.urls),
    # 用户管理
    path("accounts/", include("django.contrib.auth.urls")),  # 新增
    # 本地应用
    path("", include("pages.urls")),
]
```

`auth`应用中包含了什么？事实证明有很多。首先，有许多相关的 URL。

```python
accounts/login/ [name="login"]
accounts/logout/ [name="logout"]
accounts/password_change/ [name="password_change"]
accounts/password_change/done/ [name="password_change_done"]
accounts/password_reset/ [name="password_reset"]
accounts/password_reset/done/ [name="password_reset_done"]
accounts/reset/<uidb64>/<token>/ [name="password_reset_confirm"]
accounts/reset/done/ [name="password_reset_complete"]
```

我是如何获取这些信息的呢？主要有两种途径。首先，[Django 官方认证文档](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/#module-django.contrib.auth.views)详细列出了这些 URL 路径及其用途。其次，更为深入的方法是直接查阅 Django 源代码，这些代码都[托管在 Github 上](https://github.com/django/django)。通过导航或搜索功能，我们可以找到[auth 应用的完整实现](https://github.com/django/django/tree/b9cf764be62e77b4777b3a75ec256f6209a57671/django/contrib/auth)。在该目录中，[urls.py 文件](https://github.com/django/django/blob/b9cf764be62e77b4777b3a75ec256f6209a57671/django/contrib/auth/urls.py)清晰地展示了所有认证相关 URL 的定义和配置。

## 主页

接下来，我们需要优化现有的主页，使其能够识别用户的登录状态并相应地显示不同内容。目前，用户只能通过管理界面登录，但我们希望在主页上直观地反映这一状态。

下面是更新后的`templates/home.html`文件代码。这里我们巧妙地运用了 Django 模板引擎的[if/else](https://docs.djangoproject.com/zh-hans/5.2/ref/templates/builtins/#if)条件标签，实现了根据用户登录状态动态展示内容的功能：

```html
<!-- templates/home.html -->
{% extends "_base.html" %} {% block title %}Home{% endblock title %} {% block
content %}
<h1>这是我们的主页。</h1>
{% if user.is_authenticated %}
<p>你好 {{ user.email }}!</p>
{% else %}
<p>你尚未登录</p>
<a href="{% url 'login' %}">登录</a>
{% endif %} {% endblock content %}
```

当用户已登录（已认证）时，我们会显示一条个性化的问候语，内容为"你好"并附上他们的电子邮件地址。这些信息是通过 Django 模板引擎使用双大括号`{{`和`}}`语法来访问的[模板变量](https://docs.djangoproject.com/zh-hans/5.2/topics/templates/#variables)。

Django 的默认`User`模型包含多种有用的字段和属性，在此我们主要使用了[is_authenticated](https://docs.djangoproject.com/zh-hans/5.2/ref/contrib/auth/#django.contrib.auth.models.User.is_authenticated)（判断用户是否已登录）和[email](https://docs.djangoproject.com/zh-hans/5.2/ref/contrib/auth/#django.contrib.auth.models.User.email)（获取用户邮箱）这两个属性。

模板中的`logout`和`login`是 Django 内置的 URL 名称。[url](https://docs.djangoproject.com/zh-hans/5.2/ref/templates/builtins/#url)模板标签允许我们通过指定 URL 名称来自动生成对应的 URL 路径，无需硬编码完整路径。例如，在前面章节中我们将主页的 URL 名称设置为`home`，因此可以使用`{% url 'home' %}`在任何模板中生成指向主页的链接。这种方式使得 URL 管理更加灵活，我们将在后续章节深入探讨。

现在，如果你访问`http://127.0.0.1:8000/`主页，你应该能看到一条针对你之前登录的超级用户账户的个性化问候信息，显示其电子邮件地址。

如果你想测试未登录状态下的页面显示效果，可以通过管理界面`http://127.0.0.1:8000/admin/`右上角的"注销"按钮退出登录。完成注销后，返回主页`http://127.0.0.1:8000/`并刷新，你将看到针对未登录用户的界面。

## Django 源代码

你可能已经能够通过阅读[官方文档](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/)自己整理出这些步骤。但更深入、更有效的方法是学习如何直接阅读 Django 源代码。

你可能会好奇，`user`及其相关变量是如何自动出现在我们的模板中的？这是因为 Django 实现了一个称为[模板上下文处理器](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/#authentication-data-in-templates)的机制，它会自动将当前用户信息注入到每个模板的上下文中。这意味着我们可以在任何模板中直接访问`user`对象及其所有属性，而无需在视图中显式传递这些数据。

要检查用户是否已登录，我们只需访问`user`对象的[is_authenticated](https://docs.djangoproject.com/zh-hans/5.2/ref/contrib/auth/#django.contrib.auth.models.User.is_authenticated)属性。这是一个布尔值属性，对已登录用户返回`True`，对匿名用户返回`False`。基于这个简单的条件判断，我们可以为不同状态的用户提供个性化的内容。

那么，模板中使用的`login`这个 URL 名称又是从何而来的呢？这当然是 Django 内置认证系统提供的！让我们详细分析一下`{% url 'login' %}`这段代码。

首先，[url 模板标签](https://docs.djangoproject.com/zh-hans/5.2/ref/templates/builtins/#url)接受一个[命名的 URL 模式](https://docs.djangoproject.com/zh-hans/5.2/topics/http/urls/#naming-url-patterns)作为第一个参数。这正是我们在配置 URL 路由时通过`name`参数定义的名称。因此，Django 认证系统中用于登录功能的 URL 路由必然被命名为`'login'`。

如果你想自己探索这些内置功能，有两种主要方法：

第一种方法是查阅[官方文档](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/)。你可以使用搜索功能输入关键词如"login"，然后逐步深入相关页面。对于认证相关功能，最有用的部分是[认证视图文档](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/#module-django.contrib.auth.views)，它详细列出了所有内置认证视图及其对应的 URL 模式。

```python
accounts/login/ [name="login"]
accounts/logout/ [name="logout"]
accounts/password_change/ [name="password_change"]
accounts/password_change/done/ [name="password_change_done"]
accounts/password_reset/ [name="password_reset"]
accounts/password_reset/done/ [name="password_reset_done"]
accounts/reset/<uidb64>/<token>/ [name="password_reset_confirm"]
accounts/reset/done/ [name="password_reset_complete"]
```

这告诉我们，在路径`accounts/login/`处是"login"视图所在的位置，它的名称是`'login'`。虽然初次接触可能会感到有些困惑，但这正是我们需要了解的关键信息。

进一步深入探索，我们可以通过研究 Django 源代码来了解"logout"功能的具体实现。如果你在[Github](https://github.com/django/django)上进行搜索，你最终会找到[auth 应用的核心代码](https://github.com/django/django/tree/b9cf764be62e77b4777b3a75ec256f6209a57671/django/contrib/auth)。接下来，让我们从分析其中的`urls.py`文件入手，这是理解路由配置的最佳起点。[这里是该文件的完整代码链接](https://github.com/django/django/blob/b9cf764be62e77b4777b3a75ec256f6209a57671/django/contrib/auth/urls.py)：

```python
# django/contrib/auth/urls.py
from django.contrib.auth import views
from django.urls import path

urlpatterns = [
    path('login/', views.LoginView.as_view(), name='login'),
    path('logout/', views.LogoutView.as_view(), name='logout'),

    path('password_change/', views.PasswordChangeView.as_view(),
        name='password_change'),
    path('password_change/done/', views.PasswordChangeDoneView.as_view(),
        name='password_change_done'),
    path('password_reset/', views.PasswordResetView.as_view(),
        name='password_reset'),
    path('password_reset/done/', views.PasswordResetDoneView.as_view(),
        name='password_reset_done'),
    path('reset/<uidb64>/<token>/', views.PasswordResetConfirmView.as_view(),
        name='password_reset_confirm'),
    path('reset/done/', views.PasswordResetCompleteView.as_view(),
        name='password_reset_complete'),
]
```

这就是 Django 内部用于`auth`应用的核心代码。从中我们可以清晰地看到，"logout"路由其实并没有什么神秘之处。它就在那里，明明白白地使用了`LogoutView`视图，并被赋予了 URL 名称`'logout'`。这一切都非常直观和合理，只是对初学者来说，第一次找到这些信息可能需要一些探索。

这种三步探索法是学习 Django 的有效途径：你可以选择直接记住 Django 提供的便捷方式，或者在官方文档中查找相关信息，又或者在必要时深入研究源代码，真正理解这些强大功能背后的实现原理。通过这种方式，你不仅能够使用这些功能，还能够真正掌握它们。

## 登录

回到我们的基本主页，点击"登录"链接...结果却出现了错误！

Django 向我们抛出了一个`TemplateDoesNotExist`错误。具体来说，它在寻找位于`registration/login.html`的登录模板，但未能找到。除了错误信息提示外，我们还可以通过查阅[官方文档](https://docs.djangoproject.com/zh-hans/5.2/topics/auth/default/#all-authentication-views)确认，Django 确实期望在该位置找到所需的`template_name`。

为了彻底理解这一机制，让我们深入源代码，消除任何可能的疑惑。毕竟，Django 的强大之处在于其透明性和可探索性。

查看[auth/views.py](https://github.com/django/django/blob/b9cf764be62e77b4777b3a75ec256f6209a57671/django/contrib/auth/views.py)文件，我们可以在`LoginView`类的第 45 行清晰地看到`template_name`被设置为`'registration/login.html'`。虽然我们可以通过覆盖`LoginView`来修改这一默认路径，但这似乎有些小题大做。既然 Django 已经为我们提供了合理的默认设置，我们不妨直接采用。

接下来，我们需要在现有的`templates`目录中创建一个新的`registration`文件夹，以符合 Django 的预期目录结构，确保登录模板能被正确识别。

```bash
$ mkdir templates/registration
```

接下来，在`templates/registration`目录下创建一个`login.html`文件。以下是具体实现代码。我们继承了基础模板，设置了适当的页面标题，并创建了一个使用 POST 方法提交数据的表单。这种方式更安全，适合处理用户凭据等敏感信息。

```html
<!-- templates/registration/login.html -->
{% extends "_base.html" %} {% block title %}登录{% endblock title %} {% block
content %}
<h2>登录</h2>
<form method="post">
  {% csrf_token %} {{ form.as_p }}
  <button type="submit">登录</button>
</form>
{% endblock content %}
```

你应该**始终**在任何可提交的表单上添加[CSRF 保护](https://docs.djangoproject.com/zh-hans/5.2/ref/csrf/)。这是一项重要的安全措施，可以防止恶意网站通过跨站请求伪造攻击你的网站和用户。Django 已经为我们集成了 CSRF 中间件来处理这一安全问题；我们只需在表单开头添加`{% csrf_token %}`模板标签即可激活这一保护机制。

对于表单的视觉呈现，我们可以灵活控制其外观。在这个例子中，我们选择使用[as_p()](https://docs.djangoproject.com/zh-hans/5.2/ref/forms/api/#as-p)方法，它会将每个表单字段包装在 HTML 段落`<p>`标签中，使表单结构更加清晰整洁。

现在让我们验证一下我们的登录模板是否正常工作。请刷新`http://127.0.0.1:8000/accounts/login/`页面查看效果。

完美！我们的登录页面已经成功呈现。如果你想进一步确认功能完整性，可以返回主页并点击"登录"链接，验证导航是否正常。最后一步，请使用你的超级用户账户凭据在此登录页面上进行登录测试。

## 重定向

当你点击"登录"按钮并成功验证凭据后，系统会显示一个`Page not found (404)`错误页面。

这是因为 Django 默认将登录成功的用户重定向到`127.0.0.1:8000/accounts/profile/`路径，但在我们的项目中这个页面尚未创建。为什么 Django 会选择这个路径呢？实际上，Django 需要知道用户登录成功后应该被引导到哪里。这可能是网站主页、用户个人资料页面，或者任何其他我们指定的页面。

要解决这个问题，我们需要配置[LOGIN_REDIRECT_URL](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#login-redirect-url)设置项。默认情况下，Django 将用户重定向到`accounts/profile`路径，但我们可以轻松地修改这一行为。

这个问题有一个简单的解决方案。我们希望用户登录后直接返回网站主页，而我们已经为主页设置了 URL 名称`home`，所以只需要告诉 Django 使用这个名称作为登录后的重定向目标即可。

在`django_project/settings.py`文件底部添加以下配置：

```python
# django_project/settings.py
LOGIN_REDIRECT_URL = "home"  # 新增
```

再次尝试在`http://127.0.0.1:8000/accounts/login/`登录。成功后，它会将用户重定向到主页，并问候你刚刚登录的超级用户账户！

## 注销

现在让我们在主页上添加一个注销功能，这样用户就可以方便地退出系统。由于目前只有超级用户能够访问管理界面，为普通用户提供注销选项尤为重要。

如果查看前面提到的`auth`视图模块，我们可以发现注销功能由`LogoutView`类处理，该视图已经内置了 URL 名称`logout`。这意味着我们可以在模板中直接使用`{% url 'logout' %}`标签来引用这个视图。

为了完善用户体验，我们需要配置注销后的重定向行为。Django 提供了[LOGOUT_REDIRECT_URL](https://docs.djangoproject.com/zh-hans/5.2/ref/settings/#logout-redirect-url)设置项，可以指定用户注销后应该被引导到哪个页面。让我们将其添加到`django_project/settings.py`文件底部，设置为主页，这样用户注销后会自动返回网站首页。

> 注意：4.1 版本中弃用通过 GET 方式注销登录！

```python
# django_project/settings.py
LOGIN_REDIRECT_URL = "home"
LOGOUT_REDIRECT_URL = "home"  # 新增
```

然后将注销链接添加到`templates/home.html`。

```html
<!-- templates/home.html -->
{% extends "_base.html" %} {% block title %}Home{% endblock title %} {% block
content %}
<h1>这是我们的主页。</h1>
{% if user.is_authenticated %}
<p>你好 {{ user.email }}!</p>
<form method="post" action="{% url 'logout' %}">
  {% csrf_token %}
  <button type="submit">注销</button>
</form>
{% else %}
<p>你尚未登录</p>
<a href="{% url 'login' %}">登录</a>
{% endif %} {% endblock content %}
```

刷新`http://127.0.0.1:8000/`主页，你会看到页面上已经显示了"注销"按钮。

当你点击这个按钮后，系统会将你注销并自动重定向回主页。此时，页面上的问候语已经消失，取而代之的是"你尚未登录"的提示以及一个"登录"链接。

## 注册

实现用户注册功能是我们需要自行完成的任务。我们将按照创建新页面的标准流程进行：

- 创建应用级的`accounts/urls.py`文件
- 更新项目级`django_project/urls.py`文件，将路由指向`accounts`应用
- 添加`SignupPageView`视图处理注册逻辑
- 创建`signup.html`模板展示注册界面
- 在`home.html`中添加注册页面的入口链接

关于实现顺序的问题，其实并没有严格的先后之分，因为这些组件最终都需要协同工作才能使注册功能正常运行。虽然没有固定规则，但我个人习惯是先配置 URL 路由，然后编写视图逻辑，最后设计模板界面，这种自上而下的方式有助于理清思路。

首先，让我们创建`accounts/urls.py`文件。目前为止，我们的`accounts`应用仅包含了`models.py`中定义的`CustomUser`模型，还没有任何路由或视图配置。

我们将为注册页面设置 URL 路径为`signup/`，对应的视图是即将创建的`SignupPageView`，并将其命名为`signup`，这样后续可以通过模板标签`{% url 'signup' %}`方便地引用。值得注意的是，登录(`login`)和注销(`logout`)的 URL 名称已经在 Django 内置的认证系统中定义，位于`django/contrib/auth/urls.py`文件中。

```python
# accounts/urls.py
from django.urls import path

from .views import SignupPageView

urlpatterns = [
    path("signup/", SignupPageView.as_view(), name="signup"),
]
```

接下来需要更新`django_project/urls.py`文件，将`accounts`应用的 URL 配置纳入项目路由系统。虽然我们可以自由选择任何路由前缀，但为了保持一致性，通常会使用与 Django 默认认证系统相同的`accounts/`路径。这里有一个重要细节：我们必须将`accounts.urls`的包含语句放在`django.contrib.auth.urls`的**下方**。这是因为 Django 按照从上到下的顺序加载 URL 路径，这样安排可以确保内置认证系统的 URL 路径优先被匹配，避免可能的路由冲突。

```python
# django_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django 管理
    path("admin/", admin.site.urls),
    # 用户管理
    path("accounts/", include("django.contrib.auth.urls")),
    # 本地应用
    path("accounts/", include("accounts.urls")),  # 新增
    path("", include("pages.urls")),
]
```

现在创建视图`SignupPageView`。它引用了`CustomUserCreationForm`，并有一个指向`login`页面的`success_url`，这意味着表单提交后用户将被重定向到那里。`template_name`将是`signup.html`。

```python
# accounts/views.py
from django.urls import reverse_lazy
from django.views import generic

from .forms import CustomUserCreationForm


class SignupPageView(generic.CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy("login")
    template_name = "registration/signup.html"
```

作为最后一步，创建一个名为`templates/registration/signup.html`的文件，其代码基本上与登录页面相同。

```html
<!-- templates/registration/signup.html -->
{% extends "_base.html" %} {% block title %}注册{% endblock title %} {% block
content %}
<h2>注册</h2>
<form method="post">
  {% csrf_token %} {{ form.as_p }}
  <button type="submit">注册</button>
</form>
{% endblock content %}
```

作为最后一步，我们可以在`home.html`模板中的"登录"链接下方添加一行"注册"。这是一个单行更改。

```html
<!-- templates/home.html -->
{% extends "_base.html" %} {% block title %}Home{% endblock title %} {% block
content %}
<h1>这是我们的主页。</h1>
{% if user.is_authenticated %}
<p>你好 {{ user.email }}!</p>
<p><a href="{% url 'logout' %}">注销</a></p>
{% else %}
<p>你尚未登录</p>
<a href="{% url 'login' %}">登录</a>
<a href="{% url 'signup' %}">注册</a>
{% endif %} {% endblock content %}
```

全部完成！重新加载主页以查看我们的工作。

"注册"链接现在重定向到网页`http://127.0.0.1:8000/accounts/signup/`。

创建一个新用户，电子邮件地址为`testuser2@email.com`，用户名为`testuser2`，密码为`testpass2`。提交后，它将重定向我们到登录页面。使用新账户登录，它会重定向到主页，并显示个性化的问候语。

## 测试

对于测试，我们**无需**测试登录和注销功能，因为这些功能已经内置在 Django 中并且拥有完善的测试用例。但我们**确实需要**对自己实现的注册功能进行测试！

首先，我们需要创建一个`setUp`方法（注意不是`setUpTestClass`），该方法用于加载我们的注册页面。然后，我们将编写`test_signup_template`测试方法，用于验证状态码、使用的模板以及页面中应包含和不应包含的文本内容，这与我们在上一章中对主页进行的测试方式类似。

请在你的文本编辑器中，按照以下内容更新`accounts/tests.py`文件：

```python
# accounts/tests.py
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse  # 新增


class CustomUserTests(TestCase):
    ...


class SignUpPageTests(TestCase):  # 新增
    def setUp(self):
        url = reverse("signup")
        self.response = self.client.get(url)

    def test_signup_template(self):
        self.assertEqual(self.response.status_code, 200)
        self.assertTemplateUsed(self.response, "registration/signup.html")
        self.assertContains(self.response, "注册")
        self.assertNotContains(self.response, "嗨！我不应该出现在页面上。")
```

然后运行我们的测试。

```bash
$ docker-compose exec web python manage.py test
```

接下来我们可以测试我们的`CustomUserCreationForm`是否被使用，以及页面是否解析为`SignupPageView`。

```python
# accounts/tests.py
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse, resolve  # 新增

from .forms import CustomUserCreationForm  # 新增
from .views import SignupPageView  # 新增


class CustomUserTests(TestCase):
    ...


class SignupPageTests(TestCase):  # 新增
    def setUp(self):
        url = reverse("signup")
        self.response = self.client.get(url)

    def test_signup_template(self):
        self.assertEqual(self.response.status_code, 200)
        self.assertTemplateUsed(self.response, "registration/signup.html")
        self.assertContains(self.response, "注册")
        self.assertNotContains(self.response, "嗨！我不应该出现在页面上。")

    def test_signup_form(self):  # 新增
        form = self.response.context.get("form")
        self.assertIsInstance(form, CustomUserCreationForm)
        self.assertContains(self.response, "csrfmiddlewaretoken")

    def test_signup_view(self):  # 新增
        view = resolve("/accounts/signup/")
        self.assertEqual(view.func.__name__, SignupPageView.as_view().__name__)
```

再次运行我们的测试。

```bash
$ docker-compose exec web python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..........
----------------------------------------------------------------------
Ran 10 tests in 0.155s

OK
Destroying test database for alias 'default'...
```

## Git

```bash
$ git status
$ git add .
$ git commit -m 'ch6'
```

## 小结

本章我们成功实现了 Bookstore 项目的用户认证系统，包括登录、注销和注册功能。通过这个过程，我们学习了以下关键知识点：

- 利用了 Django 的 `auth` 应用提供的现成视图和 URL 配置，快速实现了登录和注销功能。
- 深入理解了 Django 源码，通过阅读 Django 源码加深了对框架的理解。
- 学会了使用 `{% if user.is_authenticated %}` 条件标签，根据用户登录状态动态显示不同内容。
- 配置 `LOGIN_REDIRECT_URL` 和 `LOGOUT_REDIRECT_URL`，控制用户登录和注销后的页面跳转行为。
- 实现了完整的用户注册流程，包括创建表单、视图和模板。
- 编写了全面的测试用例，验证注册页面的模板、表单和视图是否正常工作。
