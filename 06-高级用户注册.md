# 第 8 章：高级用户注册

目前我们已经实现了标准的 Django 用户注册功能，但在专业项目中，这仅仅是一个起点。我们能否对其进行更深层次的定制呢？例如，Django 默认采用的用户名/邮箱/密码模式在当今已显得有些过时。现代应用更倾向于简化流程，仅要求用户提供邮箱和密码来完成注册和登录。事实上，整个身份验证流程中的每个环节——包括表单设计、邮件通知、页面展示——都可以根据具体项目需求进行灵活定制。

在众多现代应用中，社交媒体认证已成为不可或缺的功能，即允许用户通过第三方服务（如 Google、Facebook、微信等）一键完成注册和登录过程，大大提升了用户体验。

当然，我们可以选择从零开始构建自己的解决方案，但这条路径存在明显风险：用户认证是一个错综复杂的领域，涉及众多组件和细节，同时也是一个绝对不容许出现安全漏洞的关键环节。一旦实现不当，可能会导致严重的安全问题。

因此，绝大多数专业 Django 开发者更倾向于使用广受欢迎且经过充分验证的第三方库 [django-allauth](https://github.com/pennersr/django-allauth)。在引入任何第三方包时，我们都应保持谨慎态度，毕竟这确实会在技术栈中增加一个新的依赖项。确保所选包保持活跃更新、社区支持良好且经过充分测试至关重要。值得庆幸的是，`django-allauth` 完美满足这些要求。

虽然使用过程中可能需要一些"魔法"操作，但它优雅地解决了上述所有问题，并且使各种复杂的定制变得异常简单高效，让开发者能够专注于业务逻辑而非认证细节。

## django-allauth

我们将以常规方式安装 `django-allauth`。首先将它添加到现有的 `requirements.txt` 文件中。

```txt
# requirements.txt
asgiref==3.9.1
Django==5.2.4
psycopg-binary==3.2.9
sqlparse==0.5.3
tzdata==2025.2
django-allauth==65.10.0
crispy-bootstrap5==2025.6
django-crispy-forms==2.4
```

```shell
$ docker-compose down
$ docker-compose up -d --build
```

# psycopg==3.2.9

尽管我们已经安装了`django-allauth`包，但我们的网站仍会保持原有的运行状态，这是因为我们尚未在 Django 配置中正式启用它。要完成这一步骤，我们需要修改`django_project/settings.py`文件中的`INSTALLED_APPS`配置，添加以下组件：Django 内置的可选[sites 框架](https://docs.djangoproject.com/en/4.0/ref/contrib/sites/)、`allauth`核心模块以及其账户管理功能模块`allauth.account`。

除此之外，`django-allauth`还要求我们更新 Django 的[AUTHENTICATION_BACKENDS](https://docs.djangoproject.com/en/4.0/ref/settings/#authentication-backends)设置。在默认情况下，Django 仅包含`ModelBackend`，这是支持用户通过用户名登录 Django 管理界面的必要组件。而`django-allauth`需要添加其专属的认证后端`AuthenticationBackend`，以实现用户通过电子邮件进行登录的功能。

下面展示了`django_project/settings.py`文件中需要进行的完整更新内容：

```python
# django_project/settings.py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",  # 新增
    # 第三方
    "crispy_forms",
    "crispy_bootstrap5",
    "allauth",  # 新增
    "allauth.account",  # 新增
    # 本地
    "accounts.apps.AccountsConfig",
    "pages.apps.PagesConfig",
]

# django-allauth 配置
SITE_ID = 1  # 新增
```

## 2. AUTHENTICATION_BACKENDS

Django 为任何新项目创建的`settings.py`文件包含许多显式设置——我们已经在文件中看到的那些——以及一个更长的隐式设置列表，这些设置存在但不可见。这一开始可能会令人困惑。完整的设置配置列表[可在此处获取](https://docs.djangoproject.com/en/4.0/ref/settings/)。

例如[AUTHENTICATION_BACKENDS](https://docs.djangoproject.com/en/4.0/ref/settings/#authentication-backends)设置。在后台，Django 将其设置为`'django.contrib.auth.backends.ModelBackend'`，这在 Django 尝试验证用户时使用。我们可以将以下行添加到`django_project/settings.py`中，当前行为将保持不变：

```python
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
)
```

但是，对于`django-allauth`，我们还需要添加它特定的身份验证选项，这将使我们能够切换到使用电子邮件登录。在你的`django_project/settings.py`文件底部添加以下部分：

```python
# django_project/settings.py
# django-allauth 配置
SITE_ID = 1
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",  # 新增
)
```

## 3. EMAIL_BACKEND

另一个隐式设置是[EMAIL_BACKEND](https://docs.djangoproject.com/en/4.0/ref/settings/#email-backend)。默认情况下，Django 会寻找已配置的[SMTP 服务器](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)发送电子邮件。

`django-allauth`会在用户成功注册后发送此类电子邮件，我们可以稍后自定义它，但由于我们*尚未*正确配置 SMTP 服务器，这将导致错误。

目前的解决方案是让 Django 将任何电子邮件输出到命令行控制台。因此，我们可以通过使用[console](https://docs.djangoproject.com/en/4.0/topics/email/#console-backend)而不是`smtp`来覆盖默认的隐式配置。在`settings.py`文件底部添加此内容。

```python
# django_project/settings.py
# django-allauth 配置
SITE_ID = 1
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
)
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"  # 新增
```

## 4. ACCOUNT_LOGOUT_REDIRECT

现在还有一个微妙的配置更改。如果再次查看[配置页面](https://django-allauth.readthedocs.io/en/latest/configuration.html)，你会看到有一个`ACCOUNT_LOGOUT_REDIRECT`设置，默认为主页路径`/`。

在我们当前的`settings.py`文件中，有以下两行重定向到通过 URL 名称`"home"`的主页。

```python
# django_project/settings.py
LOGIN_REDIRECT_URL = "home"
LOGOUT_REDIRECT_URL = "home"
```

问题是`django-allauth`的`ACCOUNT_LOGOUT_REDIRECT`实际上会覆盖内置的`LOGOUT_REDIRECT_URL`，但由于它们都指向主页，所以这个变化可能不会立即明显。为了未来便于扩展我们的应用程序——因为也许我们不想在注销时总是重定向到主页——我们应该在这里明确注销重定向。

我们还可以将这两行重定向放在`django-allauth配置`部分下。以下是此时整个`django-allauth配置`部分的样子。

```python
# django_project/settings.py
# django-allauth 配置
LOGIN_REDIRECT_URL = "home"
ACCOUNT_LOGOUT_REDIRECT = "home"  # 新增
SITE_ID = 1
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
)
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
```

鉴于我们对`django_project/settings.py`文件进行了多次更改，现在让我们运行`migrate`来更新数据库。

```shell
$ docker-compose exec web python manage.py migrate
Operations to perform:
  Apply all migrations: account, accounts, admin, auth, contenttypes, sessions, sites
Running migrations:
  Applying account.0001_initial... OK
  Applying account.0002_email_max_length... OK
  Applying sites.0001_initial... OK
  Applying sites.0002_alter_domain_unique... OK
```

## 5. URLs

我们还需要将内置的`auth`应用程序 URL 替换为`django-allauth`自己的`allauth`应用程序。我们仍将使用相同的`accounts/` URL 路径，但是由于我们将使用`django-allauth`的模板和注册路由，我们也可以删除我们的`accounts`应用程序的 URL 路径。

```python
# django_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # Django 管理
    path("admin/", admin.site.urls),
    # 用户管理
    path("accounts/", include("allauth.urls")),  # 新增
    # 本地应用
    path("", include("pages.urls")),
]
```

此时，我们*可以*进一步删除`accounts/urls.py`和`accounts/views.py`，因为它们都是专为我们手写的注册页面创建的，现在不再使用。

## 6. 模板

Django 的`auth`应用程序在`templates/registration`目录中寻找模板，但`allauth`更喜欢将它们放在`templates/account`目录中。因此，我们将创建一个名为`templates/account`的新目录，然后将我们现有的`login.html`和`signup.html`模板复制到其中。

```shell
$ mkdir templates/account
$ mv templates/registration/login.html templates/account/login.html
$ mv templates/registration/signup.html templates/account/signup.html
```

在这里很容易误将`account`添加`s`，但不要这样做，否则会出错。正确的目录是`templates/account/`。

我们可以在此时删除`templates/registration`目录，因为它不再需要。

```shell
$ rm -r templates/registration
```

`rm`表示删除，`-r`表示递归执行，这在处理目录时是必需的。如果你想了解有关此命令的更多信息，可以键入`man rm`阅读手册。

注意，如果你看到包含`rm -rf`的命令——尤其是`sudo rm -rf`——要格外小心！使用此命令可能会擦除整个计算机。除非你百分之百确定结果是预期的，否则不要执行它。

最后一步是更新`templates/_base.html`中的 URL 链接，使用`django-allauth`的 URL 名称而不是 Django 的。我们通过添加`account_`前缀来实现这一点，因此 Django 的`'logout'`现在将是`'account_logout'`，`'login'`将是`'account_login'`，`signup`将是`account_signup`。

```html
<!-- templates/_base.html -->
...
<ul class="navbar-nav me-auto mb-2 mb-md-0">
  <li class="nav-item">
    <a class="nav-link" href="{% url 'about' %}">关于</a>
  </li>
  {% if user.is_authenticated %}
  <li class="nav-item">
    <a class="nav-link" href="{% url 'account_logout' %}">退出登录</a>
  </li>
  {% else %}
  <li class="nav-item">
    <a class="nav-link" href="{% url 'account_login' %}">登录</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="{% url 'account_signup' %}">注册</a>
  </li>
  {% endif %}
</ul>
...
```

大功告成！

## 7. 登录

刷新主页`http://127.0.0.1:8000`，如果你已经登录，请先退出登录，然后点击"登录"链接。登录页面现已更新。

![登录页面](images\08_allauth_login.jpg) 登录页面

注意新的"记住我"复选框选项。这是`django-allauth`提供的众多[配置](https://django-allauth.readthedocs.io/en/latest/configuration.html)之一。默认的`None`会询问用户是否希望记住他们的会话，这样他们就不必再次登录。它也可以设置为`False`不记住或`True`始终记住。我们将选择`True`，这是传统 Django 登录页面的工作方式。

在`django_project/settings.py`文件的`# django-allauth 配置`部分下添加一个新行。

```python
# django_project/settings.py
# django-allauth 配置
...
ACCOUNT_SESSION_REMEMBER = True  # 新增
```

刷新"登录"页面，复选框不见了！

![无复选框的登录页面](images\08_allauth_login_no_box.jpg) 无复选框的登录页面

如果你使用超级用户账号尝试登录表单，它会重定向回带有欢迎消息的主页。点击"退出登录"链接。

![退出登录页面](images\08_logout.jpg) 退出登录页面

`django-allauth`并不直接让我们退出登录，而是有一个中间的"退出登录"页面，我们可以将其自定义为与项目的其余部分相匹配。

## 8. 退出登录

我们现在将通过创建`templates/account/logout.html`文件来覆盖默认的退出登录模板。现在在你的文本编辑器中执行此操作。与我们的其他模板一样，它将扩展`_base.html`并在`submitted`按钮上包含 Bootstrap 样式。

```html
<!-- templates/account/logout.html -->
{% extends "_base.html" %} {% load crispy_forms_tags %} {% block title
%}退出登录{% endblock %} {% block content %}
<h1>退出登录</h1>
<p>你确定要退出登录吗？</p>
<form method="post" action="{% url 'account_logout' %}">
  {% csrf_token %} {{ form|crispy }}
  <button class="btn btn-danger" type="submit">退出登录</button>
</form>
{% endblock content %}
```

继续刷新页面。

![自定义退出登录页面](images\08_custom_logout_page.jpg) 自定义退出登录页面

然后点击"退出登录"链接完成该过程。

## 9. 注册

在我们网站的顶部，在导航栏中，点击"注册"链接，它具有 Bootstrap 和`django-crispy-forms`样式。

![注册页面](images\08_signup.jpg) 注册页面

通过`django-allauth`我们可以做的一个可选自定义是只要求输入一次密码。由于我们稍后将配置密码更改和重置选项，因此用户输入错误密码而被锁定账户的风险较小。

如果你查看[django-allauth 配置选项](https://django-allauth.readthedocs.io/en/latest/configuration.html)，这个更改是一行代码。

```python
# django_project/settings.py
# django-allauth 配置
...
ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False  # 新增
```

刷新页面，表单将更新以删除额外的密码行。

![单密码注册](images\08_signup_single_password.jpg) 单密码注册

现在创建一个新用户以确认一切正常工作。我们可以将用户命名为`testuser1`，使用`testuser1@email.com`作为电子邮件，并使用`testpass123`作为密码。提交后，它会重定向到主页。

还记得我们如何配置电子邮件输出到控制台吗？`django-allauth`会在注册后自动发送电子邮件，我们可以通过输入`docker-compose logs`查看。

```shell
$ docker-compose logs
...
web_1  | Content-Type: text/plain; charset="utf-8"
web_1  | MIME-Version: 1.0
web_1  | Content-Transfer-Encoding: 7bit
web_1  | Subject: [example.com] Please Confirm Your E-mail Address
web_1  | From: webmaster@localhost
web_1  | To: testuser@email.com
web_1  | Date: Tue, 17 May 2022 14:04:15 -0000
web_1  | Message-ID: <155266195771.15.17095643701553564393@cdab877c4af3>
web_1  |
web_1  | Hello from example.com!
web_1  |
web_1  | You're receiving this e-mail because user testuser1 has given yours as
an e-mail address to connect their account.
web_1  |
web_1  | To confirm this is correct, go to http://127.0.0.1:8000/accounts/
confirm-emailMQ:1h4oIn:GYETeK5dRClGjcgA8NbuOoyvafA/
web_1  |
web_1  | Thank you from example.com!
web_1  | example.com
web_1  | -----------------------------------------------------------------------
...
```

就是这样。在本书的后面部分，我们将自定义此消息并配置适当的电子邮件服务，将其发送给实际用户。

## 10. 管理

使用你的超级用户账号登录`http://127.0.0.1:8000/admin/`的管理界面，我们可以看到它也因`django-allauth`的加入而发生了变化。

![管理首页](images\08_admin.jpg) 管理首页

这里有两个新部分：`Accounts`和`Sites`，这是我们最近工作的成果。如果你点击`Users`部分，我们会看到显示三个当前用户账号的传统视图。

![管理用户](images\missing.png) 管理用户

如果你展开页面左侧的管理侧边栏，我们可以直接转到`Sites`部分，查看 Django sites 框架提供的内容。我们将在配置电子邮件的后续章节中更新域名和显示名称。

![管理站点](images\08_sites.jpg) 管理站点

## 11. 仅邮箱登录

现在是时候真正使用`django-allauth`的[广泛配置列表](https://django-allauth.readthedocs.io/en/latest/configuration.html)，切换到仅使用电子邮件登录，而非用户名。这需要进行一些更改。首先，我们将把`username`设为不必需，但设置`email`为必需。然后，我们将要求`email`是唯一的，并作为首选的认证方法。

```python
# django_project/settings.py
# django-allauth 配置
...
ACCOUNT_USERNAME_REQUIRED = False  # 新增
ACCOUNT_AUTHENTICATION_METHOD = "email"  # 新增
ACCOUNT_EMAIL_REQUIRED = True  # 新增
ACCOUNT_UNIQUE_EMAIL = True  # 新增
```

导航回主页并点击"退出登录"，因为你将使用超级用户账号登录。然后点击导航栏中的"注册"链接，使用`testuser2@email.com`和密码`testpass123`创建一个账号。

成功后重定向到主页，进入管理员查看实际发生的情况。使用你的超级用户账号登录并导航到`Users`部分。

![管理用户](images\08_admin_testuser2.jpg) 管理用户

我们可以看到`django-allauth`根据`@`之前的电子邮件部分自动为我们填充了用户名。这是因为我们底层的`CustomUser`模型仍然有一个`username`字段。我们没有删除它。

虽然这种方法看起来有点黑客风格，但实际上它*运行良好*。完全从自定义用户模型中删除用户名需要使用[AbstractBaseUser](https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#django.contrib.auth.models.AbstractBaseUser)，这是一些开发人员采取的额外可选步骤。它需要更多的编码和理解，所以除非你真的了解 Django 的认证系统，否则不推荐这样做！

然而，这里有一个边缘情况我们应该研究：如果我们有`testuser2@email.com`然后注册`testuser2@example.com`会发生什么？这两者是否都会导致`testuser2`的用户名，从而引起冲突？让我们试一试！

退出管理员，在注册页面为`testuser2@example.com`创建账号。

![注册表单](images\08_testuser2_example_signup.jpg) 注册表单

现在重新登录管理员并转到我们的`Users`部分。

![管理用户](images\08_admin_two_testuser2.jpg) 管理用户

`django-allauth`自动为用户名添加了一个两位数的字符串。在这种情况下，它是`20`，所以`testuser2`变成了`testuser27`。这个两位数的字符串将随机生成。

## 12. 测试

是时候进行测试了。像任何优秀的第三方包一样，`django-allauth`带有自己的测试，因此我们不需要重新测试其核心功能，只需确认我们的项目按预期工作即可。

当前与`SignUpPageTests`相关的测试存在一些错误，因为我们现在使用的是`django-allauth`而不是我们自己的视图、表单和 URL。

让我们更新测试。从顶部开始，我们不再使用`CustomUserCreationForm`或`SignupPageView`，所以我们可以删除这两个导入。我们现在使用的是`django-allauth`的 URL 路径和名称，注册页面是`account_signup`，而不是我们之前命名的`signup`。我是如何知道它是`account_signup`的？我查看了[源代码](https://github.com/pennersr/django-allauth/blob/master/allauth/account/urls.py)并找到了 URL 名称。

更新后的代码如下：

```python
# accounts/tests.py
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse, resolve


class CustomUserTests(TestCase):
    ...


class SignupPageTests(TestCase):  # 新增
    username = "newuser"
    email = "newuser@email.com"

    def setUp(self):
        url = reverse("account_signup")
        self.response = self.client.get(url)

    def test_signup_template(self):
        self.assertEqual(self.response.status_code, 200)
        self.assertTemplateUsed(self.response, "account/signup.html")
        self.assertContains(self.response, "Sign Up")
        self.assertNotContains(self.response, "Hi there! I should not be on the page.")

    def test_signup_form(self):
        new_user = get_user_model().objects.create_user(self.username, self.email)
        self.assertEqual(get_user_model().objects.all().count(), 1)
        self.assertEqual(get_user_model().objects.all()[0].username, self.username)
        self.assertEqual(get_user_model().objects.all()[0].email, self.email)
```

再次运行测试。

```shell
$ docker-compose exec web python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..............
----------------------------------------------------------------------
Ran 14 tests in 0.410s

OK
Destroying test database for alias 'default'...
```

## 13. 社交登录

如果你想添加社交认证，只需要几个设置。我有一个[完整的在线教程](https://learndjango.com/tutorials/django-allauth-tutorial)用于集成 Github。这个过程对于 Google、Facebook 和所有其他`django-allauth`支持的平台都是类似的。[这里是提供者的完整列表](https://django-allauth.readthedocs.io/en/latest/providers.html)。

## 14. Git

像往常一样，用 Git 提交代码更改。

```shell
$ git status
$ git add .
$ git commit -m 'ch8'
```

如果有任何问题，请与[Github 上的官方源代码](https://github.com/wsvincent/djangoforprofessionals/tree/main/ch8-advanced-user-registration)进行比较。

## 15. 结论

我们现在拥有了一个可以工作的用户注册流程，并且可以快速扩展到社交认证。在下一章中，我们将为项目添加环境变量，以提高安全性和灵活性。
